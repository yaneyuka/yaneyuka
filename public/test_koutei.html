<!DOCTYPE html>

<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>簡易工程表</title>
<script src="https://cdn.tailwindcss.com/"></script>
<script src="https://unpkg.com/lucide@latest"></script> <!-- lucideを追加 -->
<style>
        /* test_shoubousetsubi.html からコピーするCSS ここから */
        @font-face {
            font-family: 'Logotype Gothic Condensed';
            src: url('fonts/LogotypeGothicCondensed.otf') format('opentype');
            font-weight: normal;
            font-style: normal;
        }
        /* Google Custom Searchのスタイル */
        .gsc-control-searchbox-only {
            width: 100% !important;
            margin: 0 !important;
            padding: 0 !important;
            display: flex !important;
            flex-direction: row !important;
            background-color: rgb(243 244 246) !important;
        }
        .gsc-search-box {
            width: 100% !important;
            margin: 0 !important;
            padding: 0 !important;
            background-color: #3b3b3b !important;
        }
        .gsc-input-box {
            width: 100% !important;
            margin: 0 !important;
            padding: 0 !important;
            background-color: #FFFFFF !important;
            border: none !important;
            box-shadow: none !important;
        }
        .gsc-input-box .gsc-input {
            width: 100% !important;
            margin: 0 !important;
            padding: 0 8px !important;
            background-color: #FFFFFF !important;
            color: #000000 !important;
            height: 28px !important;
            box-sizing: border-box !important;
        }
        /* 検索ボタンのスタイル */
        button.gsc-search-button,
        button.gsc-search-button-v2 {
            display: block !important;
            background-color: #6B7280 !important;
            border: none !important;
            padding: 0 !important;
            height: 31px !important;
            width: 31px !important;
            min-width: 31px !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            border-radius: 50% !important;
            margin-right: 8px !important;
            margin-left: 4px !important;
            box-shadow: none !important;
            position: relative !important;
            overflow: hidden !important;
        }
        button.gsc-search-button-v2 svg {
            width: 13px !important;
            height: 13px !important;
            margin: 0 !important;
            position: absolute !important;
            top: 50% !important;
            left: 50% !important;
            transform: translate(-50%, -50%) !important;
        }
        .gsc-search-button-v2:hover {
            background-color: #4B5563 !important;
            border-color: #3B8AC4 !important;
        }
        /* Google Search Results (if needed later) */
        .gsc-results-wrapper { width: 100% !important; }
        .gsc-results-wrapper-overlay { width: 100% !important; left: 0 !important; right: 0 !important; padding: 30px !important; box-sizing: border-box !important; top: 180px !important; height: calc(100% - 180px) !important; }
        .gsc-control-cse { padding: 0 !important; margin: 0 !important; border: none !important; background-color: transparent !important; }
        .gsc-control-cse-ja { padding: 0 !important; margin: 0 !important; }
        .gsc-control-wrapper { padding: 0 !important; margin: 0 !important; }
        .gsc-modal-background-image { background-color: rgba(0, 0, 0, 0.5) !important; top: 180px !important; height: calc(100% - 180px) !important; }
        .gsc-results-close-btn { top: 190px !important; right: 10px !important; }
        
        /* ナビゲーションバーのスタイル */
        .nav-bar {
            background-color: #00B8A9; /* デフォルトの背景色 (yaneyukaと同じにするなら変更) */
             /* background-color: #FFFFFF; /* test_koutei.html に合わせる場合 */
        }
        .nav-bar a:hover {
            background-color: #E5E7EB; /* ホバー時の背景色 (gray-200相当) */
             /* color: #1F2937; /* ホバー時の文字色 (gray-800相当) */
        }
        /* スクロールバーのスタイル */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px; /* 横スクロールバーの高さも設定 */
        }
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        ::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        /* スクロールバーによるレイアウトシフトを防ぐ */
        html {
            /* overflow-y: scroll; */ /* test_koutei では不要かも */
            scrollbar-gutter: stable;
        }
        /* スマートフォン用のスタイル (一部抜粋) */
        @media (max-width: 768px) {
             header { margin-bottom: 8px !important; padding-bottom: 8px !important; }
             nav.nav-bar { margin-top: 4px !important; margin-bottom: 8px !important; }
             body { margin: 0; padding: 0; font-size: 12px; }
             #main-layout-container { flex-direction: column !important; } /* スマホでは縦並び */
             #main-layout-container > aside { width: 100% !important; height: auto; overflow-y: visible; border-right: none; border-bottom: 1px solid #e9ecef; margin-bottom: 8px; } /* 左カラムは全幅 */
             #main-layout-container > main { width: 100% !important; margin-right: 0 !important; height: auto; overflow-y: visible; } /* メインも全幅 */
             aside.w-\[225px\] { display: none; } /* 右サイドバー非表示 */
             .accordion-toggle { text-align: left; } /* スマホでは左寄せ */
        }
        /* test_shoubousetsubi.html からコピーするCSS ここまで */

        /* 工程表のバーのスタイル (既存) */
        .task-bar {
            background-color: #3B82F6; /* 青色 */
            height: 20px;
            border-radius: 4px;
            position: absolute;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 10px;
            color: white;
            padding-left: 4px;
            line-height: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            cursor: pointer; /* カーソルを追加 */
            z-index: 6; /* z-index追加 */
        }
        .timeline-header {
            position: sticky;
            top: 0; /* JSで調整される */
            background-color: white;
            z-index: 9; /* Lower than title, higher than task name */
        }
        .task-name-col {
             position: sticky;
             left: 0;
             background-color: white; /* ここで背景色を白に固定 */
             z-index: 7; /* Increase z-index to be above task bars (z-index: 6) */
             min-width: 180px; /* 項目名の列幅を確保 */
             border-right: 1px solid #e5e7eb; /* Restore right border */
             padding-right: 8px; /* 右側のパディングを追加 */
        }
        .task-name-col-header {
            grid-row: span 2 / span 2; /* 2行にまたがる */
            border-bottom: 1px solid #e5e7eb;
            z-index: 7; /* Ensure header part is also above task bars */
        }
        /* 背景グリッド線 */
        .grid-line {
            position: absolute;
            height: 100%;
            border-left: 1px solid #e5e7eb; /* Vertical grid line */
            z-index: 3; /* 土日祝日の背景（z-index: 2）より上に表示するために3に変更 */
        }
        /* ラジオボタンのスタイル調整 */
        .view-radio-label {
            padding: 4px 10px;
            border: 1px solid #D1D5DB;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-right: 5px;
            transition: background-color 0.2s, color 0.2s;
            background-color: white;
            color: #4B5563;
            height: 26px;
            display: inline-flex;
             align-items: center;
             justify-content: center;
        }
        .view-radio-input:checked + .view-radio-label {
            background-color: #4B5563;
            border-color: #4B5563;
            color: white;
        }
        .view-radio-input:checked + .view-radio-label:hover {
            background-color: #374151;
            border-color: #374151;
        }
        .view-radio-label:hover {
            background-color: #F3F4F6;
        }
        /* 色選択ピッカーのスタイル */
        #task-color {
            border: 1px solid #d1d5db; /* Tailwind gray-300 */
            border-radius: 4px;
            width: 100%;
            height: 2rem; /* h-8 相当 */
            padding: 0;   /* パディングをリセット */
            cursor: pointer;
            box-sizing: border-box; /* 念のため */
        }
        /* タスクリストのスタイル */
        /* Remove old table styles */
        /* #task-list-container table { ... } */
        /* #task-list-container th, #task-list-container td { ... } */
        /* #task-list-container th { ... } */

        /* Keep input styles, adjust if needed */
        #task-list-container input[type="text"],
        #task-list-container input[type="date"],
        #task-list-container input[type="number"] {
             width: 100%;
             border: 1px solid #d1d5db; /* border-gray-300 */
             border-radius: 0.25rem; /* rounded */
             /* Use smaller padding for list view */
             padding: 0.1rem 0.25rem; /* py-0.5 px-1 */
             font-size: 0.75rem; /* text-xs */
             box-sizing: border-box;
         }
         /* Specific width for order input in list */
         #task-list-container input[data-field='order'] {
             width: 32px; /* Further reduced width */
             text-align: center;
         }
         #task-list-container input[type="color"] {
             width: 30px; /* Adjust width */
             height: 20px; /* Adjust height */
             padding: 1px;
             border: 1px solid #d1d5db;
             border-radius: 4px;
             cursor: pointer;
             vertical-align: middle;
         }
        /* Keep color swatch and delete button styles */
        /* #task-list-container .color-cell { ... } を削除 */
         #task-list-container .color-swatch {
             display: inline-block;
             width: 16px; /* Adjust size */
             height: 16px;
            border-radius: 4px;
             border: 1px solid #d1d5db;
             vertical-align: middle;
         }
         #task-list-container .delete-btn {
             color: #ef4444; /* red-500 */
             background: none; border: none; padding: 0; cursor: pointer;
             display: inline-flex; align-items: center; justify-content: center;
         }
         #task-list-container .delete-btn:hover { color: #dc2626; /* red-600 */ }
         #task-list-container .delete-btn svg { height: 0.875rem; width: 0.875rem; } /* Slightly smaller icon (h-3.5 w-3.5) */
         #task-list-container .delete-btn svg { height: 1rem; width: 1rem; } /* アイコンサイズ調整 */
        /* タスクリスト折りたたみ用スタイル */
        .task-list-toggle { cursor: pointer; display: inline-flex; align-items: center; width: 14px; height: 14px; margin-right: 0; transition: transform 0.2s ease-in-out; } /* サイズ調整 */
        .task-list-toggle svg { width: 1em; height: 1em; transition: transform 0.2s ease-in-out; } /* アイコンにもtransition */
        .rotate-180 svg { transform: rotate(180deg); } /* ボタンではなくSVGを回転 */
        #task-list-content { transition: max-height 0.3s ease-in-out; overflow: hidden; } /* アニメーション用 */
        /* 項目リストの順番入力欄の矢印を非表示にする */
        #task-list-container input[type=number]::-webkit-inner-spin-button,
        #task-list-container input[type=number]::-webkit-outer-spin-button {
            -webkit-appearance: none;
                margin: 0;
        }
        #task-list-container input[type=number] {
            -moz-appearance: textfield; /* Firefox 用 */
            appearance: textfield; /* 標準 */
        }
    
@media print {
  body * {
    visibility: hidden !important;
  }
  #main-layout-container > main,
  #main-layout-container > main * {
    visibility: visible !important;
    print-color-adjust: exact !important; /* 変更 */
    -webkit-print-color-adjust: exact !important; /* Safari/Chrome用に追加 */
  }
  #main-layout-container > main {
    position: absolute !important;
    left: 0 !important;
    top: 0 !important;
    width: 100% !important;
    margin: 0 !important;
    padding: 0 !important;
    background-color: white !important;
    z-index: 9999;
  }
}
</style>
</head>
<body class="bg-white font-sans" style="font-family: 'Logotype Gothic Condensed', sans-serif;"> <!-- 背景を白に変更 -->
<!-- ヘッダー (test_shoubousetsubi.html からコピー) -->
<header class="relative border-gray-300 mb-2">
<div class="relative bg-[#3b3b3b] pt-4 pb-4 px-4">
<!-- Links Div (Absolute Positioned) -->
<div class="absolute top-2 right-4">
<div class="flex gap-4 text-[11px] text-white">
<a class="hover:underline" href="userpage.html">USER PAGE</a>
<a class="hover:underline" href="#" onclick="showRegister()">新規会員登録</a>
<a class="hover:underline" href="#" onclick="showPublishForm(event)">掲載希望はコチラ</a>
<a class="hover:underline" href="#" onclick="showFeedbackForm(event)">ご意見・ご要望</a>
<a class="hover:underline" href="#" id="authButton" onclick="showLogin()">login</a>
</div>
</div>
<!-- Logo/Desc Div -->
<div class="flex flex-col items-start gap-2">
<div class="flex items-end gap-2">
<a href="index.html">
<img alt="yaneyuka" class="h-12" src="image/yaneyukaロゴ3.png"/>
</a>
<p class="text-[9pt] text-white">～建築土木の総合情報サイト～</p>
</div>
</div>
<!-- Search Div -->
<div class="flex flex-col items-center mt-4 relative">
<div class="w-full max-w-2xl">
<script async="" src="https://cse.google.com/cse.js?cx=926ccd1b95a9649b8"></script>
<div class="gcse-search" data-linktarget="_blank"></div>
</div>
</div>
</div>
<nav class="flex flex-wrap md:flex-nowrap overflow-x-auto whitespace-nowrap text-gray-100 text-sm mb-4" style="background-color: #1dad95;">
<a class="nav-item px-4 py-2 hover:bg-gray-200 transition cursor-pointer md:ml-[110pt]" href="index.html?page=topix">Toppage</a>
<a class="nav-item px-4 py-2 hover:bg-gray-200 transition cursor-pointer" href="index.html?page=event">イベント情報</a>
<a class="nav-item px-4 py-2 hover:bg-gray-200 transition cursor-pointer" href="index.html?page=new">新商品</a>
<a class="nav-item px-4 py-2 hover:bg-gray-200 transition cursor-pointer" href="index.html?page=book">書籍・ソフト</a>
<a class="nav-item px-4 py-2 hover:bg-gray-200 transition cursor-pointer" href="index.html?page=houki">法規</a>
<a class="nav-item px-4 py-2 hover:bg-gray-200 transition cursor-pointer" href="index.html?page=cad">添景・CAD</a>
<a class="nav-item px-4 py-2 hover:bg-gray-200 transition cursor-pointer" href="index.html?page=tool">ツール</a>
<a class="nav-item px-4 py-2 hover:bg-gray-200 transition cursor-pointer" href="index.html?page=company">施工会社</a>
<a class="nav-item px-4 py-2 hover:bg-gray-200 transition cursor-pointer" href="index.html?page=office">設計事務所</a>
<a class="nav-item px-4 py-2 hover:bg-gray-200 transition cursor-pointer" href="index.html?page=job">求人情報</a>
</nav>
</header>
<!-- 2カラムレイアウトコンテナ -> 3カラムレイアウトコンテナ -->
<div class="flex gap-4 p-4 items-start" id="main-layout-container"> <!-- items-start 追加 -->
<!-- 左サイドバー：Usertools と プロジェクト情報・工程追加 (横並び) -->
<aside class="flex shrink-0 text-[14px] space-x-4"> <!-- w-[280px]削除, flex追加, space-x-4追加 -->
<!-- Usertools (固定幅) -->
<div class="w-32 shrink-0 space-y-6"> <!-- 幅を w-32 に縮小 -->
<h3 class="text-lg font-semibold mb-2 cursor-default">Usertools</h3>
<div class="space-y-0">
<div><button class="w-full text-left px-4 py-2 cursor-pointer accordion-toggle text-[13px] text-gray-600" onclick="window.location.href='userpage.html?section=myhouki'">My法規</button></div>
<div><button class="w-full text-left px-4 py-2 cursor-pointer accordion-toggle text-[13px] text-gray-600" onclick="window.location.href='userpage.html?section=todo'">Myタスク</button></div>
<div><button class="w-full text-left px-4 py-2 cursor-pointer accordion-toggle text-[13px] text-gray-600" onclick="window.location.href='userpage.html?section=teamtodo'">Teamタスク</button></div>
<div><button class="w-full text-left px-4 py-2 cursor-pointer accordion-toggle text-[13px] text-gray-600" onclick="window.location.href='userpage.html?section=generaltools'">一般ツール</button></div>
<div><button class="w-full text-left px-4 py-2 cursor-pointer accordion-toggle text-[13px] text-gray-600" onclick="window.location.href='userpage.html?section=designtools'">設計ツール</button></div>
<div><button class="w-full text-left px-4 py-2 cursor-pointer accordion-toggle text-[13px] text-gray-600" onclick="window.location.href='userpage.html?section=contact'">担当連絡先</button></div>
<div><button class="w-full text-left px-4 py-2 cursor-pointer accordion-toggle text-[13px] text-gray-600" onclick="window.location.href='userpage.html?section=settings'">設定</button></div>
</div>
</div>
<!-- プロジェクト情報 と 工程追加 (固定幅に変更) -->
<div class="space-y-3 w-52"> <!-- space-y-6 から space-y-3 に変更 -->
<!-- ★★★ プロジェクト管理UIを変更 ★★★ -->
<div class="bg-gray-100 p-2 rounded-lg border border-gray-200 space-y-2">
<h3 class="text-base font-semibold mb-1">プロジェクト管理</h3>
<!-- Select blijft -->
<div class="flex items-center gap-1">
<select class="border border-gray-300 rounded px-2 py-1 text-xs focus:outline-none focus:border-gray-400 flex-grow h-7" id="project-select">
<option value="">-- プロジェクトを選択 --</option>
<!-- 保存されたプロジェクトがここに追加されます -->
</select>
<!-- 削除ボタンをここから削除 -->
<!-- <button id="delete-project-btn" ... </button> -->
</div>
<!-- 新規作成・保存ボタンはそのまま -->
<div class="flex gap-1">
<button class="flex-1 text-xs bg-green-500 hover:bg-green-600 text-white px-2 py-1 rounded transition h-7" id="create-new-project-btn">新規作成</button>
<button class="flex-1 text-xs bg-indigo-500 hover:bg-indigo-600 text-white px-2 py-1 rounded transition h-7" id="save-project-btn">保存</button>
</div>
<!-- ★ プロジェクト削除用リストを追加 ★ -->
<div class="mt-2" id="project-deletion-list-container">
<p class="text-[10px] text-gray-600 mb-1">プロジェクト削除:</p>
<div class="max-h-32 overflow-y-auto border border-gray-200 bg-white rounded p-1 space-y-0.5" id="project-deletion-list">
<!-- 削除可能なプロジェクトリストがここに追加されます -->
<p class="text-gray-400 text-xs italic p-1">保存されたプロジェクトはありません。</p>
</div>
</div>
</div>
<!-- ★★★ ここまで変更 ★★★ -->
<!-- ▼▼▼ プロジェクト情報 ▼▼▼ -->
<div class="bg-gray-100 p-2 rounded-lg border border-gray-200"> <!-- 背景色変更(50->100), パディング変更(4->2) -->
<h3 class="text-base font-semibold mb-2">プロジェクト情報</h3>
<div class="mb-4">
<!-- 変更：ラベルを上に配置 -->
<label class="block text-xs font-medium text-gray-700 mb-1" for="project-name-input">プロジェクト名</label> <!-- text-sm から text-xs に変更 -->
<input class="w-full border border-gray-300 rounded px-3 py-1.5 text-sm focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500" id="project-name-input" placeholder="例：〇〇邸新築工事" type="text"/>
</div>
</div>
<!-- ▲▲▲ プロジェクト情報 ▲▲▲ -->
<!-- ▼▼▼ 表示設定 (移動してきた要素) ▼▼▼ -->
<div class="bg-gray-100 p-2 rounded-lg border border-gray-200 space-y-3"> <!-- 背景色変更(50->100), パディング変更(4->2) -->
<h3 class="text-base font-semibold mb-2">表示設定</h3>
<!-- 表示単位 ラジオボタン -->
<div id="view-type-selector">
<label class="block text-xs font-medium text-gray-700 mb-1">表示単位</label>
<div> <!-- ラジオボタンをインライン表示するためのdiv -->
<input checked="" class="sr-only view-radio-input" id="view-day" name="view-type" type="radio" value="day"/>
<label class="view-radio-label" for="view-day">日</label>
<input class="sr-only view-radio-input" id="view-week" name="view-type" type="radio" value="week"/>
<label class="view-radio-label" for="view-week">週</label>
<input class="sr-only view-radio-input" id="view-month" name="view-type" type="radio" value="month"/>
<label class="view-radio-label" for="view-month">月</label>
</div>
</div>
<!-- 祝日表示切り替え -->
<div class="flex items-center">
<input class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500" id="show-holidays" type="checkbox"/>
<label class="ml-2 block text-xs text-gray-900" for="show-holidays">祝日を表示</label>
</div>
<!-- バー内日付表示切り替え -->
<div class="flex items-center">
<input class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500" id="show-start-date" type="checkbox"/>
<label class="ml-2 block text-xs text-gray-900" for="show-start-date">バー内開始日</label>
</div>
<div class="flex items-center">
<input class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500" id="show-end-date" type="checkbox"/>
<label class="ml-2 block text-xs text-gray-900" for="show-end-date">バー内終了日</label>
</div>
<!-- 表示期間指定 -->
<div>
<label class="block text-xs font-medium text-gray-700 mb-1">表示期間</label>
<div class="grid grid-cols-2 gap-1 items-center"> <!-- flex -> grid, gap-1, items-center追加 -->
<input class="border border-gray-300 rounded px-1 py-1 text-[10px] focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500 h-8 box-border w-full" id="display-start-date" type="date"/> <!-- flex-grow削除, text-[10px], h-8, box-border, w-full 追加 -->
<input class="border border-gray-300 rounded px-1 py-1 text-[10px] focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500 h-8 box-border w-full" id="display-end-date" type="date"/> <!-- flex-grow削除, text-[10px], h-8, box-border, w-full 追加 -->
</div>
<button class="mt-1 w-full bg-gray-600 text-white px-3 py-1 rounded hover:bg-gray-700 transition-colors text-xs font-medium" id="apply-display-period">決定</button>
</div>
</div>
<!-- ▲▲▲ 表示設定 ▲▲▲ -->
<!-- ▼▼▼ 工程追加 ▼▼▼ -->
<form class="bg-gray-100 p-2 rounded-lg border border-gray-200" id="task-form"> <!-- 背景色変更(50->100), パディング変更(4->2) -->
<h3 class="text-base font-semibold mb-2">工程追加</h3>
<div class="grid grid-cols-1 gap-2"> <!-- gap-3 から gap-2 に変更 -->
<div> <!-- 変更：ラベルを上に -->
<label class="block text-xs font-medium text-gray-700 mb-1" for="task-name">工程名</label>
<input class="w-full border border-gray-300 rounded px-3 py-1 text-xs focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500 h-8 box-border" id="task-name" placeholder="工程名" required="" type="text"/>
</div>
<!-- 変更：開始日と終了日を横並びにする (Gridに変更) -->
<div class="grid grid-cols-2 gap-2"> <!-- Use grid with 2 columns and gap -->
<div> <!-- Start Date Container (no flex-1 needed) -->
<label class="block text-[10px] font-medium text-gray-600 mb-0.5" for="start-date">開始日</label>
<input class="w-full border border-gray-300 rounded px-1 py-1 text-[10px] focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500 h-8 box-border" id="start-date" required="" type="date"/>
</div>
<div> <!-- End Date Container (no flex-1 needed) -->
<label class="block text-[10px] font-medium text-gray-600 mb-0.5" for="end-date">終了日</label>
<input class="w-full border border-gray-300 rounded px-1 py-1 text-[10px] focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500 h-8 box-border" id="end-date" required="" type="date"/>
</div>
</div>
<div> <!-- 変更：ラベルを上に -->
<label class="block text-[10px] font-medium text-gray-600 mb-0.5" for="inner-text">内文字</label> <!-- 担当 から 内文字 に変更 -->
<input class="w-full border border-gray-300 rounded px-3 py-1 text-xs focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500 h-8 box-border" id="inner-text" placeholder="バー内文字" type="text"/> <!-- 担当者または会社名 から バー内文字 に変更 -->
</div>
<!-- 変更：色選択と追加ボタンを横並びにする -->
<div class="flex items-end gap-2">
<div class="flex-grow">
<label class="block text-[10px] font-medium text-gray-600 mb-0.5" for="task-color">色</label>
<input class="w-full border border-gray-300 rounded cursor-pointer box-border align-middle h-8" id="task-color" type="color" value="#3B82F6"/>
</div>
<!-- TODO: 画像にある「標準」ドロップダウンをここに追加するか確認 -->
<button class="bg-gray-600 text-white px-3 py-1 rounded hover:bg-gray-700 transition-colors text-xs font-medium w-auto flex-shrink-0 box-border h-8" type="submit">追加</button> <!-- 色を決定ボタンに合わせる (bg-blue-600 -> bg-gray-600, hover:bg-blue-700 -> hover:bg-gray-700) -->
</div>
</div>
</form>
<!-- ▲▲▲ 工程追加 ▲▲▲ -->
<!-- サポートツール（仮）-->
<div class="bg-gray-100 p-2 rounded-lg border border-gray-200"> <!-- 背景色変更(50->100), パディング変更(4->2) -->
<h3 class="text-base font-semibold mb-2">サポートツール</h3>
<!-- ... -->
</div>
</div>
</aside>
<!-- 中央カラム：メインコンテンツ (工程表など) (可変幅) -->
<main class="flex-grow overflow-x-auto"> <!-- overflow-x-auto追加 -->
<!-- ボタン類は右サイドバーへ移動 -->
<!-- 工程表表示エリア (移動) -->
<div class="bg-white rounded-lg shadow-md overflow-x-auto mb-8 border border-gray-300"> <!-- 枠線を追加 -->
<h2 class="text-lg font-semibold mb-4 text-gray-700 px-4 pt-4" id="chart-area-title" style="width: auto; max-width: 100%;">工程表</h2>
<div class="relative min-w-full pb-4" id="gantt-chart">
<p class="text-gray-500 text-sm px-4">タスクを追加してください。</p>
</div>
</div>
</main>
<!-- ★★★ 右サイドバー：項目リストと広告 ★★★ -->
<aside class="w-[225px] shrink-0 text-[14px] space-y-6">
<!-- ▼▼▼ エクスポート/プリントボタン (移動) ▼▼▼ -->
<div class="flex justify-end items-center"> <!-- mb-4 を削除 -->
<button class="bg-gray-200 text-gray-700 px-3 py-1 rounded hover:bg-gray-300 transition-colors text-xs font-medium mr-2" id="export-button">エクスポート</button>
<button class="bg-gray-200 text-gray-700 px-3 py-1 rounded hover:bg-gray-300 transition-colors text-xs font-medium" id="pdf-print-button" onclick="window.print()">プリント</button> <!-- スプリント -> プリント -->
</div>
<!-- ▲▲▲ エクスポート/プリントボタン ▲▲▲ -->
<!-- ▼▼▼ タスクリスト表示エリア (移動) ▼▼▼ -->
<div class="bg-gray-100 p-2 rounded-lg border border-gray-300" id="task-list-container"> <!-- shadow-md を削除 -->
<h3 class="text-base font-semibold mb-2 border-b pb-2">項目リスト</h3> <!-- タイトル変更、折りたたみ削除 -->
<div class="mt-3" id="task-list-content">
<!-- リストはここにJavaScriptで描画されます -->
<p class="text-gray-500 text-sm">タスクはまだありません。</p>
</div>
</div>
<!-- ▲▲▲ タスクリスト表示エリア ▲▲▲ -->
<!-- ▼▼▼ お知らせ (削除) ▼▼▼ -->
<!-- ▼▼▼ 広告 (仮) ▼▼▼ -->
<div>
<h4 class="text-[12px] font-semibold mb-1">広告</h4>
<div class="bg-gray-200 h-32 mb-2 flex items-center justify-center text-gray-500 text-xs rounded">広告枠1</div>
<div class="bg-gray-200 h-32 flex items-center justify-center text-gray-500 text-xs rounded">広告枠2</div>
</div>
<!-- ▲▲▲ 広告 ▲▲▲ -->
</aside>
</div>
<script>
        // --- グローバル変数と初期化 ---
        let savedProjects = []; // プロジェクトデータを格納する配列 {id, name, tasks}
        let currentProjectId = null; // 現在表示/編集中プロジェクトのID (新規ならnull)
        let tasks = []; // 現在表示中のプロジェクトのタスク配列

        // --- 旧localStorage読み込み部分をコメントアウトまたは削除 ---
        // let tasks = JSON.parse(localStorage.getItem('ganttTasks')) || [];
        // let maxOrder = 0;
        // tasks.forEach((task, index) => { ... });
        // maxOrder = Math.max(maxOrder, tasks.length);
        // tasks.sort((a, b) => (a.order ?? Infinity) - (b.order ?? Infinity));

        const taskForm = document.getElementById('task-form');
        const showHolidaysCheckbox = document.getElementById('show-holidays');
        const showHolidaysLabel = document.querySelector('label[for="show-holidays"]'); // ラベルを取得
        // Remove old checkbox element reference
        // const showDatesCheckbox = document.getElementById('show-dates');
        // Add new checkbox element references
        const showStartDateCheckbox = document.getElementById('show-start-date');
        const showEndDateCheckbox = document.getElementById('show-end-date');

        const taskNameInput = document.getElementById('task-name');
        const displayStartDateInput = document.getElementById('display-start-date'); // 表示期間開始日
        const displayEndDateInput = document.getElementById('display-end-date');   // 表示期間終了日
        // Remove old label reference
        // const showDatesLabel = document.querySelector('label[for="show-dates"]');
        const startDateInput = document.getElementById('start-date');
        const applyDisplayPeriodButton = document.getElementById('apply-display-period'); // 決定ボタン
        const endDateInput = document.getElementById('end-date');
        const taskColorInput = document.getElementById('task-color');
        const innerTextInput = document.getElementById('inner-text');
        const ganttChartDiv = document.getElementById('gantt-chart');
        const viewTypeRadios = document.querySelectorAll('input[name="view-type"]');
        const taskListContainer = document.getElementById('task-list-container');
        const taskListContent = document.getElementById('task-list-content');
        const taskListToggleButton = document.getElementById('task-list-toggle-btn');
        const ganttTitleElement = document.getElementById('chart-area-title');
        const projectNameInput = document.getElementById('project-name-input');
        // ★★★ 新しく追加したUI要素を取得 ★★★
        const projectSelect = document.getElementById('project-select');
        const createNewProjectBtn = document.getElementById('create-new-project-btn');
        const saveProjectBtn = document.getElementById('save-project-btn');
        // ★★★ ここまで追加 ★★★

        // ★★★ 追加: 削除リストコンテナの要素取得 ★★★
        const projectDeletionListDiv = document.getElementById('project-deletion-list');

        // --- Helper Functions ---
        let holidays = {}; // 祝日データ格納用
        let showHolidays = localStorage.getItem('ganttShowHolidays') === 'true'; // 祝日表示状態
        // Remove old state variable
        // let showDatesInBar = localStorage.getItem('ganttShowDatesInBar') !== 'false';
        // Add new state variables (default to true)
        let showStartDateInBar = localStorage.getItem('ganttShowStartDateInBar') !== 'false';
        let showEndDateInBar = localStorage.getItem('ganttShowEndDateInBar') !== 'false';

        let displayStartDate = localStorage.getItem('ganttDisplayStartDate') || ''; // 表示期間開始日
        let displayEndDate = localStorage.getItem('ganttDisplayEndDate') || '';   // 表示期間終了日

        // --- Robust Date Helper Functions (UTC based) ---
        function getStartOfDayUTCMillis(date) {
            if (!(date instanceof Date) || isNaN(date.getTime())) {
                console.warn("Invalid date passed to getStartOfDayUTCMillis:", date);
                return NaN; 
            }
            return Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
        }

        function diffInDaysUTC(d1, d2) {
            const date1UTCMillis = getStartOfDayUTCMillis(d1);
            const date2UTCMillis = getStartOfDayUTCMillis(d2);
            if (isNaN(date1UTCMillis) || isNaN(date2UTCMillis)) {
                console.error("Cannot calculate day difference due to invalid date(s).", d1, d2);
                return 0; 
            }
            const millisecondsPerDay = 1000 * 60 * 60 * 24;
            return Math.round((date1UTCMillis - date2UTCMillis) / millisecondsPerDay);
        }

        // --- Suggested getStartOfWeek implementation (ChatGPT-4o based) ---
        const getStartOfWeek = (date) => {
            // Ensure we work with a UTC date internally
            const d = new Date(Date.UTC(
                date.getUTCFullYear(),
                date.getUTCMonth(),
                date.getUTCDate()
            ));

            if (isNaN(d.getTime())) { 
                console.error("Invalid date passed to getStartOfWeek, using current week fallback:", date);
                const today = new Date();
                const todayDayFallback = today.getUTCDay();
                const diffFallback = (todayDayFallback + 6) % 7;
                today.setUTCDate(today.getUTCDate() - diffFallback);
                return new Date(Date.UTC(today.getUTCFullYear(), today.getUTCMonth(), today.getUTCDate()));
            }

            const day = d.getUTCDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday
            const diff = (day + 6) % 7; // Offset to get to Monday
            d.setUTCDate(d.getUTCDate() - diff); // Apply the offset to get Monday
            return d; // Return the modified date object (already UTC)
        };
        // --- End of suggested getStartOfWeek ---

        // --- NEW Helper function for fixed 4-week rule ---
        const getFixedWeekOfMonth = (date) => {
            const day = date.getUTCDate();
            let week = 0;
            let dayPosition = 0; // 週内の位置 (0.0～1.0)
            
            if (day >= 1 && day <= 7) {
                week = 1;
                dayPosition = (day - 1) / 7; // 1日目は0/7=0.0、7日目は6/7=0.857...
            } else if (day >= 8 && day <= 14) {
                week = 2;
                dayPosition = (day - 8) / 7; // 8日目は0/7=0.0、14日目は6/7=0.857...
            } else if (day >= 15 && day <= 22) {
                week = 3;
                dayPosition = (day - 15) / 8; // 15日目は0/8=0.0、22日目は7/8=0.875
            } else {
                week = 4;
                // 23日から月末までの日数は月によって異なるため、相対位置を計算
                const lastDay = new Date(Date.UTC(
                    date.getUTCFullYear(),
                    date.getUTCMonth() + 1,
                    0
                )).getUTCDate(); // 月の最終日
                
                dayPosition = (day - 23) / (lastDay - 22); // 23日目は0、月末は1.0
            }
            
            return { week, dayPosition };
        };
        // --- End NEW Helper ---

        const getStartOfMonth = (date) => {
            const d = new Date(date);
            if (isNaN(d.getTime())) { 
                console.error("Invalid date passed to getStartOfMonth:", date);
                const today = new Date();
                return new Date(Date.UTC(today.getUTCFullYear(), today.getUTCMonth(), 1));
            }
            return new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), 1));
        };

        const formatDate = (date) => date.toISOString().split('T')[0];
        function escapeHtml(unsafe) { if (typeof unsafe !== 'string') return unsafe; return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;"); }

        // --- Function to Fetch Japanese Holidays --- 
        async function fetchHolidays() {
            try {
                const response = await fetch('https://holidays-jp.github.io/api/v1/date.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                holidays = await response.json(); // Assign fetched data to the global holidays object
                console.log('Holidays fetched:', holidays);
            } catch (error) {
                console.error('Error fetching holidays:', error);
                holidays = {}; // Reset holidays on error
            }
        }
        // --- End Fetch Holidays --- 

        // --- Event Listeners ---
        taskForm.addEventListener('submit', (event) => {
             event.preventDefault();
             const taskName = taskNameInput.value.trim();
             const startDate = startDateInput.value;
             const endDate = endDateInput.value;
             const taskColor = taskColorInput.value;
             const innerText = innerTextInput.value.trim();
             if (!taskName || !startDate || !endDate) { alert('全ての項目を入力してください。'); return; }
             if (new Date(startDate) > new Date(endDate)) { alert('終了日は開始日以降に設定してください。'); return; }

             maxOrder++;
             const newTask = {
                 id: Date.now(),
                 name: taskName,
                 start: startDate,
                 end: endDate,
                 color: taskColor,
                 innerText: innerText,
                 order: maxOrder // Assign new order
             };
             tasks.push(newTask);
             // No need to sort here, it will be placed at the end by default

             taskForm.reset();
             innerTextInput.value = '';
             taskColorInput.value = "#3B82F6";
             saveTasks();
             renderGanttChart();
             if (taskListContent.classList.contains('hidden')) {
                 toggleTaskList();
             }
        });

        showHolidaysCheckbox.checked = showHolidays;
        showHolidaysCheckbox.addEventListener('change', async (event) => {
            showHolidays = event.target.checked;
            localStorage.setItem('ganttShowHolidays', showHolidays);
            if (showHolidays && Object.keys(holidays).length === 0) {
                await fetchHolidays(); // 祝日データがなければ取得
            }
            renderGanttChart();
        });

        // Add new event listeners
        showStartDateCheckbox.checked = showStartDateInBar;
        showStartDateCheckbox.addEventListener('change', (event) => {
            showStartDateInBar = event.target.checked;
            localStorage.setItem('ganttShowStartDateInBar', showStartDateInBar);
            renderGanttChart();
        });

        showEndDateCheckbox.checked = showEndDateInBar;
        showEndDateCheckbox.addEventListener('change', (event) => {
            showEndDateInBar = event.target.checked;
            localStorage.setItem('ganttShowEndDateInBar', showEndDateInBar);
            renderGanttChart();
        });

        // 表示期間入力欄の初期値設定
        displayStartDateInput.value = displayStartDate; 
        displayEndDateInput.value = displayEndDate;

        // 「決定」ボタンのクリックイベント
        applyDisplayPeriodButton.addEventListener('click', () => {
            const newStartDate = displayStartDateInput.value;
            const newEndDate = displayEndDateInput.value;

            // 状態変数とLocalStorageを更新
            displayStartDate = newStartDate;
            displayEndDate = newEndDate;
            localStorage.setItem('ganttDisplayStartDate', displayStartDate);
            localStorage.setItem('ganttDisplayEndDate', displayEndDate);

            // チャートを再描画
            renderGanttChart(); 
        });

        // Function to update the state of the 'Show Dates' checkbox based on view type
        function updateShowDatesCheckboxState() {
            // Keep the checkbox always enabled, regardless of view type
            showStartDateCheckbox.disabled = false;
            showEndDateCheckbox.disabled = false;
            // Ensure the label style reflects the enabled state
            showStartDateCheckbox.classList.remove('text-gray-400');
            showStartDateCheckbox.classList.add('text-gray-900');
            showEndDateCheckbox.classList.remove('text-gray-400');
            showEndDateCheckbox.classList.add('text-gray-900');

            // Original logic that disabled based on day view:
            // const selectedView = document.querySelector('input[name="view-type"]:checked').value;
            // const isDisabled = selectedView === 'day';
            // showDatesCheckbox.disabled = isDisabled;
            // showDatesLabel.classList.toggle('text-gray-400', isDisabled); // グレー表示
            // showDatesLabel.classList.toggle('text-gray-900', !isDisabled);
        }

        // --- NEW Function to update Holiday checkbox state --- 
        function updateHolidayCheckboxState() {
            const selectedView = document.querySelector('input[name="view-type"]:checked').value;
            const isDisabled = selectedView === 'week' || selectedView === 'month';
            showHolidaysCheckbox.disabled = isDisabled;
            showHolidaysLabel.classList.toggle('text-gray-400', isDisabled); // Disable style
            showHolidaysLabel.classList.toggle('text-gray-900', !isDisabled); // Enable style
        }
        // --- END NEW Function ---

        // Add event listener for view type change
        viewTypeRadios.forEach(radio => {
            radio.addEventListener('change', () => {
                updateShowDatesCheckboxState();
                updateHolidayCheckboxState(); // 祝日チェックボックスの状態も更新
                renderGanttChart();
            });
        });

        projectNameInput.addEventListener('input', updateProjectName);

        // --- Core Functions ---
        function deleteTask(taskId) {
            const taskToDelete = tasks.find(task => task.id === taskId);
            const taskName = taskToDelete ? escapeHtml(taskToDelete.name) : 'このタスク';
            if (confirm(`「${taskName}」を削除しますか？`)) {
                tasks = tasks.filter(task => task.id !== taskId);
                // No need to re-assign maxOrder here, gaps are okay
                saveTasks();
                renderGanttChart();
            }
        }

        function saveTasks() {
            localStorage.setItem('ganttTasks', JSON.stringify(tasks));
            renderTaskList();
        }

        function toggleTaskList() {
             const isHidden = taskListContent.classList.toggle('hidden');
             taskListToggleButton.classList.toggle('rotate-180', !isHidden);
        }

        function handleTaskUpdate(event) {
            const input = event.target;
            const row = input.closest('div[data-task-id]');
            if (!row || !row.dataset.taskId) { console.error('Update failed: Could not find task ID from row.'); return; }
            const taskId = parseInt(row.dataset.taskId, 10);
            const field = input.dataset.field;
            if (!field) { console.error('Update failed: Input is missing data-field attribute.'); return; }

            let newValue = input.value;
            const taskIndex = tasks.findIndex(t => t.id === taskId);
            if (taskIndex === -1) { console.error(`Update failed: Task with ID ${taskId} not found.`); return; }
            const oldValue = tasks[taskIndex][field];

            // --- Validation --- 
            if (field === 'start' || field === 'end') {
                const startDate = field === 'start' ? newValue : tasks[taskIndex].start;
                const endDate = field === 'end' ? newValue : tasks[taskIndex].end;
                const startDt = new Date(startDate); const endDt = new Date(endDate);
                if (isNaN(startDt.getTime()) || isNaN(endDt.getTime())) { alert('無効な日付形式です。'); input.value = oldValue; return; }
                if (startDt > endDt) { alert('終了日は開始日以降に設定してください。'); input.value = oldValue; return; }
            } else if (field === 'name' && newValue.trim() === '') {
                 alert('項目名は空にできません。'); input.value = oldValue; return;
             } else if (field === 'order') {
                 const numValue = parseInt(newValue, 10);

                 // 入力値のバリデーション (1以上の整数か？)
                 if (isNaN(numValue) || numValue < 1) {
                      alert('順番には1以上の数値を入力してください。');
                      input.value = oldValue ?? ''; // Revert
                      // ここで再描画して元の値に戻すのが親切かもしれない
                      // renderTaskList(); // 必要に応じてコメント解除
                      return;
                  }
                 newValue = numValue; // Use the parsed number

                 // --- ▼▼▼ 再採番ロジック ▼▼▼ ---
                 const targetTaskIndex = tasks.findIndex(t => t.id === taskId);
                 // findIndex は上でチェック済みだが念のため
                 if (targetTaskIndex === -1) { return; }
                 const targetTask = tasks[targetTaskIndex];

                 // 入力された順番が現在のタスク数を超える場合は、タスク数に丸める
                 if (newValue > tasks.length) {
                     newValue = tasks.length;
                     // input.value = newValue; // 必要なら入力フィールドも更新
                 }

                 // 現在の順番からタスクを一時的に削除
                 tasks.splice(targetTaskIndex, 1);

                 // 新しい位置にタスクを挿入 (spliceの第1引数は0始まりのindex)
                 tasks.splice(newValue - 1, 0, targetTask);

                 // 全てのタスクに1から順番を再割り当て
                 tasks.forEach((task, index) => {
                     task.order = index + 1;
                 });

                 // maxOrderを更新 (常にタスク数になる)
                 maxOrder = tasks.length;

                 saveTasks(); // 保存 & リスト再描画
                 renderGanttChart(); // ガントチャートも更新

                 // 重要: 再描画後にフォーカスを維持する (renderTaskList内で処理されるはず)
                 // そのため、この後の処理は不要なので return する
                 return;
                 // --- ▲▲▲ 再採番ロジック ▲▲▲ ---

             } else if (field === 'innerText') {
                 // No validation needed for empty string
             }

            // --- 再採番ロジックを通らなかった場合の処理 ---
            // --- Update data --- 
            tasks[taskIndex][field] = newValue;

            // --- Sort if order changed --- 
            // 再採番ロジックを通った場合は、すでにソートされているので不要
            // if (field === 'order') {
            //     tasks.sort((a, b) => (a.order ?? Infinity) - (b.order ?? Infinity));
            // }

            saveTasks(); // Save potentially reordered tasks

            // --- Update UI --- 
             if (field === 'color') {
                 // タスク詳細内のカラースウォッチを探す
                 const detailsDiv = row.querySelector(`#task-details-${taskId}`);
                 const swatch = detailsDiv ? detailsDiv.querySelector('.color-swatch') : null;
                 if (swatch) swatch.style.backgroundColor = newValue;
             }

            // Re-render everything after update and potential sort
            renderGanttChart();
        }

        function renderTaskList() {
             const focusedElement = document.activeElement; let focusedTaskId = null; let focusedField = null;

            // Keep track of which accordions are open
            const openAccordionIds = new Set();
            taskListContent.querySelectorAll('.task-details:not(.hidden)').forEach(el => {
                openAccordionIds.add(el.id);
            });

            // Determine focused element before clearing
            if (taskListContent.contains(focusedElement) && focusedElement.tagName === 'INPUT' && focusedElement.closest('div[data-task-id]') && focusedElement.dataset.field) {
               focusedTaskId = focusedElement.closest('div[data-task-id]').dataset.taskId;
               focusedField = focusedElement.dataset.field;
            }

            taskListContent.innerHTML = ''; // Clear previous list content

            if (tasks.length === 0) {
                const p = document.createElement('p');
                p.className = 'text-gray-500 text-sm';
                p.textContent = 'タスクはまだありません。';
                taskListContent.appendChild(p);
                return;
            }

            // No table, build divs for each task
             tasks.forEach(task => {
                const taskDiv = document.createElement('div');
                taskDiv.className = 'border-b border-gray-200 py-2 space-y-1 text-xs'; // Container for one task
                taskDiv.dataset.taskId = task.id;
                const inputIdBase = `list-task-${task.id}`;
                const defaultColor = task.color || '#3B82F6';

                // --- Row 1: Toggle, Order and Name ---
                const row1 = document.createElement('div');
                row1.className = 'flex items-center gap-1';

                // Accordion Toggle Button
                const toggleButton = document.createElement('button');
                toggleButton.type = 'button';
                toggleButton.className = 'task-list-toggle p-0 mr-1 flex-shrink-0'; // Use existing toggle style base
                toggleButton.setAttribute('aria-expanded', 'false'); // Accessibility
                toggleButton.setAttribute('aria-controls', `task-details-${task.id}`); // Accessibility
                toggleButton.dataset.target = `#task-details-${task.id}`;
                toggleButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-chevron-down transition-transform duration-200"><path d="m6 9 6 6 6-6"/></svg>`;
                row1.appendChild(toggleButton);

                // Order Input
                 const inputOrder = document.createElement('input');
                 inputOrder.type = 'number';
                 inputOrder.id = `${inputIdBase}-order`;
                inputOrder.value = task.order ?? '';
                 inputOrder.dataset.taskId = task.id;
                 inputOrder.dataset.field = 'order';
                inputOrder.className = 'border rounded px-1 py-0.5 text-xs'; // Width is set via CSS
                inputOrder.min = "1";
                row1.appendChild(inputOrder);

                // Name Input
                const inputName = document.createElement('input');
                inputName.type = 'text';
                inputName.id = `${inputIdBase}-name`;
                inputName.value = task.name;
                inputName.dataset.taskId = task.id;
                inputName.dataset.field = 'name';
                inputName.className = 'flex-grow border rounded px-1 py-0.5 text-xs min-w-0'; // Grow and allow shrinking
                row1.appendChild(inputName);

                // --- Details Container (Hidden by default) ---
                const detailsDiv = document.createElement('div');
                detailsDiv.id = `task-details-${task.id}`;
                // Start hidden, add padding when open
                detailsDiv.className = 'task-details hidden space-y-1 mt-1 pl-5'; // pl-5 for indentation

                // --- Row 2: Start Date and End Date ---
                const row2 = document.createElement('div');
                row2.className = 'grid grid-cols-2 gap-1'; // Use grid for dates

                // Start Date
                const startDiv = document.createElement('div');
                const startLabel = document.createElement('label');
                startLabel.htmlFor = `${inputIdBase}-start`;
                startLabel.className = 'block text-[10px] text-gray-600';
                startLabel.textContent = '開始';
                const inputStart = document.createElement('input');
                inputStart.type = 'date';
                inputStart.id = `${inputIdBase}-start`;
                inputStart.value = task.start;
                inputStart.dataset.taskId = task.id;
                inputStart.dataset.field = 'start';
                inputStart.className = 'w-full border rounded px-1 py-0.5 text-xs font-normal'; // Added font-normal
                inputStart.style.fontSize = '0.65rem'; // Smaller font size
                startDiv.appendChild(startLabel);
                startDiv.appendChild(inputStart);
                row2.appendChild(startDiv);

                // End Date
                const endDiv = document.createElement('div');
                const endLabel = document.createElement('label');
                endLabel.htmlFor = `${inputIdBase}-end`;
                endLabel.className = 'block text-[10px] text-gray-600';
                endLabel.textContent = '終了';
                const inputEnd = document.createElement('input');
                inputEnd.type = 'date';
                inputEnd.id = `${inputIdBase}-end`;
                inputEnd.value = task.end;
                inputEnd.dataset.taskId = task.id;
                inputEnd.dataset.field = 'end';
                inputEnd.className = 'w-full border rounded px-1 py-0.5 text-xs font-normal'; // Added font-normal
                inputEnd.style.fontSize = '0.65rem'; // Smaller font size
                endDiv.appendChild(endLabel);
                endDiv.appendChild(inputEnd);
                row2.appendChild(endDiv);

                detailsDiv.appendChild(row2); // Add row 2 to details div

                // Row 4: バー内文字 (変更: Row 3 の前に移動)
                const row4 = document.createElement('div');
                row4.className = 'mt-1';
                const innerTextLabel = document.createElement('label');
                innerTextLabel.htmlFor = `${inputIdBase}-innerText`;
                innerTextLabel.className = 'block text-[10px] text-gray-600';
                innerTextLabel.textContent = '内文字';
                const inputInnerText = document.createElement('input');
                inputInnerText.type = 'text';
                inputInnerText.id = `${inputIdBase}-innerText`;
                inputInnerText.value = task.innerText || '';
                inputInnerText.dataset.taskId = task.id;
                inputInnerText.dataset.field = 'innerText';
                inputInnerText.className = 'w-full border rounded px-1 py-0.5 text-xs';
                row4.appendChild(innerTextLabel);
                row4.appendChild(inputInnerText);
                detailsDiv.appendChild(row4); // Add row 4 (Inner Text) before row 3

                // --- Row 3: Color and Delete Action (変更: Row 4 の後に移動) ---
                const row3 = document.createElement('div');
                row3.className = 'flex items-center justify-between gap-1 mt-1'; // Add mt-1 for spacing

               // Color Picker + Swatch
               const colorDiv = document.createElement('div');
               colorDiv.className = 'flex items-center gap-1';
                const inputColor = document.createElement('input');
                inputColor.type = 'color';
                inputColor.id = `${inputIdBase}-color`;
                inputColor.value = defaultColor;
                inputColor.dataset.taskId = task.id;
                inputColor.dataset.field = 'color';
                // inputColor.className = '...'; // Style is applied via CSS selector
                const colorSwatch = document.createElement('span');
                colorSwatch.className = 'color-swatch'; // Style is applied via CSS selector
                colorSwatch.style.backgroundColor = defaultColor;
                colorDiv.appendChild(inputColor);
                colorDiv.appendChild(colorSwatch);
                row3.appendChild(colorDiv);

                // Delete Button
                const deleteButton = document.createElement('button');
                deleteButton.className = 'delete-btn'; // Style is applied via CSS selector
                deleteButton.title = '削除';
                 deleteButton.onclick = () => deleteTask(task.id);
                deleteButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-trash-2"><path d="M3 6h18"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></svg>`; // アイコンを Lucide trash-2 に変更
                row3.appendChild(deleteButton);

                detailsDiv.appendChild(row3); // Add row 3 (Color/Delete) after row 4

                taskDiv.appendChild(row1);      // Append row 1 (toggle, order, name)
                taskDiv.appendChild(detailsDiv); // Append details div

                taskListContent.appendChild(taskDiv);

                // Restore open state and set aria-expanded
                const isOpen = openAccordionIds.has(detailsDiv.id);
                if (isOpen) {
                    detailsDiv.classList.remove('hidden');
                    toggleButton.querySelector('svg').classList.add('rotate-180');
                }
                toggleButton.setAttribute('aria-expanded', isOpen.toString());
            });

            // --- Re-attach Event Listeners ---
             const inputs = taskListContent.querySelectorAll('input[data-field]');
             inputs.forEach(input => {
                  const eventType = (input.type === 'date' || input.type === 'color' || input.type === 'number') ? 'change' : 'blur';
                  input.addEventListener(eventType, handleTaskUpdate);
                  if (input.type === 'text' || input.type === 'number') {
                      input.addEventListener('keydown', (event) => {
                          if (event.key === 'Enter') {
                              handleTaskUpdate(event);
                              event.target.blur();
                          } else if (event.key === 'Escape') {
                             event.target.blur(); // Just blur on escape
                          }
                      });
                  }
             });

             // --- Restore Focus --- 
              if (focusedTaskId && focusedField) {
                 const elementToFocus = taskListContent.querySelector(`[data-task-id='${focusedTaskId}'] [data-field='${focusedField}']`);
                 if (elementToFocus) {
                     setTimeout(() => {
                         elementToFocus.focus();
                         if (elementToFocus.select) { // Check if select method exists
                           elementToFocus.select();
                         } else if (elementToFocus.type === 'text' || elementToFocus.type === 'date' || elementToFocus.type === 'number') {
                             elementToFocus.selectionStart = elementToFocus.selectionEnd = elementToFocus.value.length;
                         }
                     }, 0);
                 }
            }
        }

        // --- Accordion Event Listener (Using Event Delegation) ---
        let isAccordionListenerAttached = false;
        if (!isAccordionListenerAttached) {
            taskListContent.addEventListener('click', (event) => {
                const toggleButton = event.target.closest('.task-list-toggle');
                if (!toggleButton) return;

                const targetSelector = toggleButton.dataset.target;
                if (!targetSelector) return;

                const detailsDiv = taskListContent.querySelector(targetSelector);
                if (!detailsDiv) return;

                const isOpening = detailsDiv.classList.toggle('hidden');
                const isOpen = !isOpening;
                toggleButton.querySelector('svg').classList.toggle('rotate-180', isOpen);
                toggleButton.setAttribute('aria-expanded', isOpen.toString());
            });
            isAccordionListenerAttached = true; // Prevent attaching multiple listeners
        }

        function renderGanttChart() {
             console.log('--- renderGanttChart START ---'); // Log Start
             ganttChartDiv.innerHTML = ''; // Clear previous chart
             if (tasks.length === 0) {
                 ganttChartDiv.innerHTML = '<p class="text-gray-500 text-sm px-4">タスクを追加してください。</p>';
                 renderTaskList(); // Still render the (empty) task list
                 return;
             }

             const selectedView = document.querySelector('input[name="view-type"]:checked').value;

             // --- Determine overall date range from tasks (needed for default view) ---
             let overallMinDateTask, overallMaxDateTask;
             const validTasksForRange = tasks.filter(t => !isNaN(new Date(t.start + 'T00:00:00')) && !isNaN(new Date(t.end + 'T00:00:00')));
             if (validTasksForRange.length > 0) {
                 overallMinDateTask = new Date(validTasksForRange[0].start + 'T00:00:00');
                 overallMaxDateTask = new Date(validTasksForRange[0].end + 'T00:00:00');
                 validTasksForRange.forEach(task => {
                     const start = new Date(task.start + 'T00:00:00');
                     const end = new Date(task.end + 'T00:00:00');
                     if (start < overallMinDateTask) overallMinDateTask = start;
                     if (end > overallMaxDateTask) overallMaxDateTask = end;
                 });
             } else {
                 // No valid tasks, set a default range (e.g., this month)
                 const today = new Date();
                 overallMinDateTask = new Date(Date.UTC(today.getFullYear(), today.getMonth(), 1));
                 overallMaxDateTask = new Date(Date.UTC(today.getFullYear(), today.getMonth() + 1, 0));
             }

             // --- Determine effective display period (user specified or default) ---
              let effectiveMinDate, effectiveMaxDate;
              let isPeriodSpecified = false;
              if (displayStartDate && displayEndDate) {
                 // Ensure display period dates are parsed as UTC midnight
                 effectiveMinDate = new Date(displayStartDate + 'T00:00:00Z');
                 effectiveMaxDate = new Date(displayEndDate + 'T00:00:00Z');
                 if (isNaN(effectiveMinDate.getTime()) || isNaN(effectiveMaxDate.getTime())) {
                     console.warn("Invalid display period dates, using task range.");
                     effectiveMinDate = new Date(overallMinDateTask); // These are already UTC from task parsing
                     effectiveMaxDate = new Date(overallMaxDateTask); // These are already UTC from task parsing
                 } else if (effectiveMinDate > effectiveMaxDate) {
                      [effectiveMinDate, effectiveMaxDate] = [effectiveMaxDate, effectiveMinDate]; // Swap
                  isPeriodSpecified = true;
              } else {
                      isPeriodSpecified = true;
                 }
                   } else {
                 effectiveMinDate = new Date(overallMinDateTask); // Use UTC task dates
                 effectiveMaxDate = new Date(overallMaxDateTask); // Use UTC task dates
             }

             // --- Timeline boundaries (inclusive start, exclusive end for loops) ---
             let timelineStartDate, timelineEndDate;

             // --- Initialize common variables ---
             let headerHtml = '';
             let bodyHtml = '';
             let gridHtml = '';
             let totalUnits = 0;
             let unitWidth = 0;
             let chartWidth = 0;
             let headerRows = 1;
             let headerGridTemplateRows = 'auto';
             let columnsStyle = '';
             const nameColWidth = 180;
             const rowHeight = 35;
             let taskNameHeaderHtml = `<div class="task-name-col font-semibold text-xs text-gray-700 border-r flex items-center justify-center">項目</div>`;

             // --- Calculate timeline boundaries based on view type --- 
               if (selectedView === 'week') {
                 // Use the fixed 4-week rule - boundaries are based on months covering the effective range
                 timelineStartDate = getStartOfMonth(effectiveMinDate);
                 // End date needs to be the start of the month *after* the effectiveMaxDate's month
                 timelineEndDate = new Date(Date.UTC(effectiveMaxDate.getUTCFullYear(), effectiveMaxDate.getUTCMonth() + 1, 1));
               } else if (selectedView === 'month') {
                   timelineStartDate = getStartOfMonth(effectiveMinDate);
                 timelineEndDate = new Date(Date.UTC(effectiveMaxDate.getUTCFullYear(), effectiveMaxDate.getUTCMonth() + 1, 1));
             } else { // day
                   timelineStartDate = new Date(effectiveMinDate);
                   timelineEndDate = new Date(effectiveMaxDate);
                 timelineEndDate.setUTCDate(timelineEndDate.getUTCDate() + 1); // Make end date exclusive
                 // Add padding if no period specified
                   if (!isPeriodSpecified) { 
                     timelineStartDate.setUTCDate(timelineStartDate.getUTCDate() - 2);
                     timelineEndDate.setUTCDate(timelineEndDate.getUTCDate() + 3);
                 }
             }

             // --- Filter tasks to render based on effective period ---
             const tasksToRender = tasks.filter(task => {
                 try {
                     // Ensure dates are parsed as UTC midnight
                     const taskStart = new Date(task.start + 'T00:00:00Z');
                     const taskEnd = new Date(task.end + 'T00:00:00Z');
                     // Check for overlap with the effective period
                       return taskEnd >= effectiveMinDate && taskStart <= effectiveMaxDate;
                   } catch (e) {
                     return false; // Exclude tasks with invalid dates
                   }
             });
   
             // --- Handle case where no tasks are rendered --- 
               if (tasksToRender.length === 0 && tasks.length > 0) {
                   ganttChartDiv.innerHTML = '<p class="text-gray-500 text-sm px-4">指定された期間に該当するタスクはありません。</p>';
                   renderTaskList();
                   return;
             } else if (tasks.length === 0) {
                 // Already handled at the beginning
                   return;
               }
   
             // --- Generate Chart Header and Body based on View Type ---
   
               if (selectedView === 'day') {
                   // ... (Day view logic remains the same) ...
                   // Make sure taskNameHeaderHtml has correct classes for day view
                    taskNameHeaderHtml = `<div class="task-name-col ${selectedView === 'day' ? 'task-name-col-header' : 'border-b'} font-semibold text-xs text-gray-700 border-r flex items-center justify-center" style="position: sticky; left: 0; background-color: white;">項目</div>`;
                    headerRows = 2;
                   headerGridTemplateRows = 'auto auto';
                   unitWidth = 30; // 35から30に変更
                    totalUnits = diffInDaysUTC(timelineEndDate, timelineStartDate);
                    // Set higher z-index for background highlights
                    let weekendBackgroundHtml = '<div class="absolute top-0 left-0 w-full h-full" style="z-index: 2;">'; // 背景コンテナ (z-index: 2)
                    let yearRowHtml = '';
                    let dayRowHtml = '';
                   let currentYear = -1;
                    let yearStartColIndex = 2;
                    let currentDate = new Date(timelineStartDate);

                    while (currentDate < timelineEndDate) {
                        const year = currentDate.getUTCFullYear();
                        const colIndex = diffInDaysUTC(currentDate, timelineStartDate) + 2;

                       if (year !== currentYear) {
                            if (currentYear !== -1) {
                               const prevYearColSpan = (colIndex - 1) - yearStartColIndex + 1;
                                  const yearBorderStyle = yearStartColIndex === 2 ? '' : 'border-left-width: 1px;'; // Conditional border
                                   yearRowHtml += `<div class="text-center border-b text-sm font-semibold text-gray-700 flex items-center justify-center" style="grid-row: 1; grid-column: ${yearStartColIndex} / span ${prevYearColSpan}; ${yearBorderStyle}">${currentYear}年</div>`;
                           }
                           currentYear = year;
                            yearStartColIndex = colIndex;
                        }

                        const month = currentDate.getUTCMonth() + 1;
                        const day = currentDate.getUTCDate();
                        const dayOfWeek = ['日','月','火','水','木','金','土'][currentDate.getUTCDay()];
                       let dayClass = 'text-gray-600';
                       let weekendBgClass = '';
                        if (currentDate.getUTCDay() === 0) { dayClass = 'bg-red-50 text-red-700'; weekendBgClass = 'bg-red-50'; }
                        else if (currentDate.getUTCDay() === 6) { dayClass = 'bg-blue-50 text-blue-700'; weekendBgClass = 'bg-blue-50'; }
                       const dateString = formatDate(currentDate);
                       const holidayName = showHolidays ? holidays[dateString] : null;
                        if (holidayName) { dayClass = 'bg-red-100 text-red-800'; weekendBgClass = 'bg-red-100'; }
                       let titleAttr = holidayName ? ` title="${escapeHtml(holidayName)}"` : '';
                          const dayBorderStyle = colIndex === 2 ? '' : 'border-left-width: 1px;'; // Conditional border
                           dayRowHtml += `<div class="text-center border-b text-[10px] font-medium ${dayClass} flex flex-col justify-center py-1" style="grid-row: 2; grid-column: ${colIndex}; ${dayBorderStyle}"${titleAttr}><div>${month}/${day}</div><div class="text-[9px]">${dayOfWeek}</div></div>`;
                       if (weekendBgClass) {
                           // Calculate left position carefully for background
                           const bgLeft = nameColWidth + (colIndex - 2) * unitWidth; // Adjusted index
                           weekendBackgroundHtml += `<div class="absolute ${weekendBgClass}" style="left: ${bgLeft}px; top: 0; width: ${unitWidth}px; height: ${tasksToRender.length * rowHeight}px;"></div>`;
                       }
                        columnsStyle += ` ${unitWidth}px`;
                        currentDate.setUTCDate(currentDate.getUTCDate() + 1);
                   }
                   if (currentYear !== -1) {
                        const finalYearColSpan = totalUnits - (yearStartColIndex - 2) + 1; // Adjusted index
                           const finalYearBorderStyle = yearStartColIndex === 2 ? '' : 'border-left-width: 1px;'; // Conditional border
                           yearRowHtml += `<div class="text-center border-b text-sm font-semibold text-gray-700 flex items-center justify-center" style="grid-row: 1; grid-column: ${yearStartColIndex} / span ${finalYearColSpan}; ${finalYearBorderStyle}">${currentYear}年</div>`;
                    }
                    weekendBackgroundHtml += '</div>';
                    // Ensure the header task name cell is sticky left and has a background
                    taskNameHeaderHtml = `<div class="task-name-col ${selectedView === 'day' ? 'task-name-col-header' : 'border-b'} font-semibold text-xs text-gray-700 border-r flex items-center justify-center" style="position: sticky; left: 0; background-color: white;">項目</div>`;
                    headerHtml = taskNameHeaderHtml + yearRowHtml + dayRowHtml;
                    chartWidth = totalUnits * unitWidth;

                    // Day view pxPerDay calculation
                    let pxPerDay = unitWidth;

                    // --- Day View Body Generation --- 
                    gridHtml = ''; // Reset grid HTML for day view
                    // Start loop from i = 1 to skip the first grid line (use task-name-col border instead)
                    for (let i = 1; i <= totalUnits; i++) { // Loop starts from 1
                           // Removed the -1px offset from the left calculation
                           gridHtml += `<div class="grid-line" style="left: ${nameColWidth + i * unitWidth}px; top: 0; height: ${tasksToRender.length * rowHeight}px;"></div>`;
                    }
                    bodyHtml += `<div class="relative" style="height: ${tasksToRender.length * rowHeight}px; width: ${nameColWidth + chartWidth}px;">`;
                       bodyHtml += gridHtml; // Add grid lines first
                       bodyHtml += weekendBackgroundHtml; // Add weekend background after grid lines

                    tasksToRender.forEach((task, index) => {
                       // Ensure dates are parsed as UTC midnight
                       const taskStartDate = new Date(task.start + 'T00:00:00Z');
                       const taskEndDate = new Date(task.end + 'T00:00:00Z');
                       const startOffsetDays = diffInDaysUTC(taskStartDate, timelineStartDate);
                       const durationDays = diffInDaysUTC(taskEndDate, taskStartDate) + 1;
                       const topPosition = index * rowHeight + (rowHeight - 20) / 2;
                       const leftPosition = nameColWidth + startOffsetDays * pxPerDay;
                       const barWidth = durationDays * pxPerDay - 2;

                          bodyHtml += `<div class="task-row-area absolute top-0 left-0 w-full border-b border-gray-200" style="top: ${index * rowHeight}px; height: ${rowHeight}px; z-index: 3;"></div>`;
                       // Remove absolute positioning from inline style, rely on CSS class for sticky
                       bodyHtml += `<div class="task-name-col text-xs text-gray-800 px-2 flex items-center bg-white border-b border-gray-200" style="top: ${index * rowHeight}px; height: ${rowHeight}px; width: ${nameColWidth}px;"><span class="truncate" title="${escapeHtml(task.name)}">${escapeHtml(task.name)}</span></div>`;

                       if (barWidth > 0) {
                           const effectiveLeft = Math.max(nameColWidth, leftPosition);
                           const effectiveRight = Math.min(nameColWidth + chartWidth, leftPosition + barWidth);
                           let effectiveWidth = Math.max(0, effectiveRight - effectiveLeft);

                           if (effectiveWidth > 0) {
                               let barContentHtml = '';
                               let barClasses = 'task-bar flex items-center'; // Base class
                               const taskInnerText = task.innerText || '';
                               const escapedInnerText = escapeHtml(taskInnerText);
                               const startStr = `${taskStartDate.getUTCMonth() + 1}/${taskStartDate.getUTCDate()}`;
                               const endStr = `${taskEndDate.getUTCMonth() + 1}/${taskEndDate.getUTCDate()}`;

                               let startHtml = showStartDateInBar ? `<span>${startStr}</span>` : '';
                               let endHtml = showEndDateInBar ? `<span>${endStr}</span>` : '';
                               let innerHtml = escapedInnerText ? `<span class="flex-grow text-center px-1 truncate">${escapedInnerText}</span>` : '<span class="flex-grow"></span>'; // Placeholder if no inner text

                               // Always use flex container, content adjusts based on flags
                               barClasses = 'task-bar flex items-center'; // Ensure base class
                               barContentHtml = `
                                  <span class="flex justify-between items-center w-full h-full text-white text-[9px] overflow-hidden whitespace-nowrap px-1">
                                      ${startHtml}
                                      ${innerHtml}
                                      ${endHtml}
                                  </span>`;

                               bodyHtml += `<div class="${barClasses}"
                                          title="${escapeHtml(task.name)}: ${task.start} ~ ${task.end}"
                                           style="top: ${topPosition}px; left: ${effectiveLeft}px; width: ${effectiveWidth}px; z-index: 6; background-color: ${task.color || '#3B82F6'};">
                                               ${barContentHtml}
                                      </div>`;
                           }
                       }
                   });
                   bodyHtml += '</div>'; // Close relative container

               } else if (selectedView === 'week') {
                   // --- Rewrite for Fixed 4-Week Rule --- 
                      // Ensure the header task name cell spans both rows for week view
                      // Add task-name-col-header class and grid-row: span 2
                      taskNameHeaderHtml = `<div class="task-name-col task-name-col-header flex items-center justify-center font-semibold text-xs text-gray-700 border-b border-r" style="position: sticky; left: 0; background-color: white;">項目</div>`;
                   headerRows = 2; // Month row + Fixed Week row
                   headerGridTemplateRows = 'auto auto';
                   unitWidth = 60; // Width for each fixed week (1W, 2W, 3W, 4W)
                   totalUnits = 0; // Will be calculated based on months in range

                   // Header variables
                   let monthRowHtml = '';
                   let weekRowHtml = ''; // Will contain 1W, 2W, 3W, 4W repeating
                   let currentColIndex = 2; // Grid columns start from 2 (after nameCol)
                   columnsStyle = '';

                   // Loop through each month from timelineStartDate to timelineEndDate
                   let tempDate = new Date(timelineStartDate);
                   let monthStartColIndex = 2;

                   while (tempDate < timelineEndDate) {
                       const year = tempDate.getUTCFullYear();
                       const month = tempDate.getUTCMonth();
                       totalUnits += 4; // Each month gets 4 fixed weeks

                       // Add month header cell
                       const monthColSpan = 4; // Always 4 weeks per month
                       monthRowHtml += `<div class="text-center border-b border-r text-sm font-semibold text-gray-700 flex items-center justify-center" style="grid-row: 1; grid-column: ${currentColIndex} / span ${monthColSpan};">${year}年 ${month + 1}月</div>`;

                       // Add the 4 fixed week header cells
                       for (let i = 1; i <= 4; i++) {
                           weekRowHtml += `<div class="text-center border-b border-r text-[10px] font-medium text-gray-600 flex items-center justify-center py-1" style="grid-row: 2; grid-column: ${currentColIndex};">${i}W</div>`;
                       columnsStyle += ` ${unitWidth}px`;
                           currentColIndex++;
                       }

                       // Move to the next month
                       tempDate.setUTCMonth(tempDate.getUTCMonth() + 1);
                   }

                   // Combine headers: Task Name Header first, then month row, then week row
                      // 二度目の定義を削除 (元々の正しい定義を保持するため)
                   headerHtml = taskNameHeaderHtml + monthRowHtml + weekRowHtml;
                   chartWidth = totalUnits * unitWidth;

                   // Grid lines
                   gridHtml = ''; // Reset grid html
               for (let i = 0; i <= totalUnits; i++) {
                   gridHtml += `<div class="grid-line" style="left: ${nameColWidth + i * unitWidth -1}px; top: 0; height: ${tasksToRender.length * rowHeight}px;"></div>`;
               }
               bodyHtml += `<div class="relative" style="height: ${tasksToRender.length * rowHeight}px; width: ${nameColWidth + chartWidth}px;">`;
                   bodyHtml += gridHtml; // Add grid lines

                   // --- Bar Rendering for Fixed 4-Week Rule --- 
                   // Helper to get the overall "fixed week index" from the timeline start (0-based)
                      const getOverallFixedWeekIndex = (targetDate, isEndDate = false) => {
                       // Clamp date within the timeline boundaries for index calculation
                       const clampedDate = new Date(Math.max(timelineStartDate.getTime(), Math.min(targetDate.getTime(), timelineEndDate.getTime() - 1))); // -1ms because timelineEnd is exclusive

                       let monthsDiff = (clampedDate.getUTCFullYear() - timelineStartDate.getUTCFullYear()) * 12 +
                                        (clampedDate.getUTCMonth() - timelineStartDate.getUTCMonth());

                          const fixedWeekInfo = getFixedWeekOfMonth(clampedDate); // { week, dayPosition }
                          
                          // 終了日の場合、その日の終わり (23:59:59) を表すよう調整
                          let dayPosition = fixedWeekInfo.dayPosition;
                          if (isEndDate) {
                              // すでに割合は日ごとに計算されているので、同じ日の終わりを表すために+0.999だけする
                              // 週の境界を超えないように最大0.999
                              dayPosition = Math.min(dayPosition + 0.999/7, 0.999); 
                          }

                          // 整数部分は週のインデックス、小数部分は週内の位置
                          return monthsDiff * 4 + (fixedWeekInfo.week - 1) + dayPosition;
                   };

               tasksToRender.forEach((task, index) => {
                       // Ensure dates are parsed as UTC midnight
                       const taskStartDate = new Date(task.start + 'T00:00:00Z');
                       const taskEndDate = new Date(task.end + 'T00:00:00Z');

                       // Skip tasks entirely outside the timeline (should be caught by filter, but as safety)
                       if (taskEndDate < timelineStartDate || taskStartDate >= timelineEndDate) return;

                          const startWeekIndex = getOverallFixedWeekIndex(taskStartDate, false);
                          const endWeekIndex = getOverallFixedWeekIndex(taskEndDate, true); // 終了日フラグをtrueに

                       const topPosition = index * rowHeight + (rowHeight - 20) / 2;
                          // 週のインデックスに基づいて左位置を計算（小数部も含める）
                          const leftPosition = nameColWidth + Math.floor(startWeekIndex) * unitWidth + 
                                              (startWeekIndex % 1) * unitWidth;
                          // 週の幅に基づいて幅を計算（小数部も含める）
                          const barWidth = (endWeekIndex - startWeekIndex) * unitWidth - 2; // 視認性のための余白

                          bodyHtml += `<div class="task-row-area absolute top-0 left-0 w-full border-b border-gray-200" style="top: ${index * rowHeight}px; height: ${rowHeight}px; z-index: 3;"></div>`;
                   // Remove absolute positioning from inline style, rely on CSS class for sticky
                   bodyHtml += `<div class="task-name-col text-xs text-gray-800 px-2 flex items-center bg-white border-b border-gray-200" style="top: ${index * rowHeight}px; height: ${rowHeight}px; width: ${nameColWidth}px;"><span class="truncate" title="${escapeHtml(task.name)}">${escapeHtml(task.name)}</span></div>`;
  
                       // --- Render Task Bar --- 
                       if (barWidth > 0) {
                           // Clamp bar start and end to the visible chart area
                           const effectiveLeft = Math.max(nameColWidth, leftPosition);
                           const maxRight = nameColWidth + chartWidth;
                           const effectiveRight = Math.min(maxRight, leftPosition + barWidth);
                           let effectiveWidth = Math.max(0, effectiveRight - effectiveLeft);

                   if (effectiveWidth > 0) {
                       let barContentHtml = '';
                               let barClasses = 'task-bar flex items-center';
                       const taskInnerText = task.innerText || '';
                               const escapedInnerText = escapeHtml(taskInnerText || '');
                               const startStr = `${taskStartDate.getUTCMonth() + 1}/${taskStartDate.getUTCDate()}`;
                               const endStr = `${taskEndDate.getUTCMonth() + 1}/${taskEndDate.getUTCDate()}`;

                               let startHtml = showStartDateInBar ? `<span>${startStr}</span>` : '';
                               let endHtml = showEndDateInBar ? `<span>${endStr}</span>` : '';
                               let innerHtml = escapedInnerText ? `<span class="flex-grow text-center px-1 truncate">${escapedInnerText}</span>` : '<span class="flex-grow"></span>'; // Placeholder if no inner text

                               // Always use flex container, content adjusts based on flags
                               barClasses = 'task-bar flex items-center'; // Ensure base class
                               barContentHtml = `
                                  <span class="flex justify-between items-center w-full h-full text-white text-[9px] overflow-hidden whitespace-nowrap px-1">
                                      ${startHtml}
                                      ${innerHtml}
                                      ${endHtml}
                                  </span>`;

                               bodyHtml += `<div class="${barClasses}"
                                          title="${escapeHtml(task.name)}: ${task.start} ~ ${task.end}"
                                           style="top: ${topPosition}px; left: ${effectiveLeft}px; width: ${effectiveWidth}px; z-index: 6; background-color: ${task.color || '#3B82F6'};">
                                               ${barContentHtml}
                                      </div>`;
                           }
                       }
                   }); // End tasksToRender.forEach

                   bodyHtml += '</div>'; // Close relative container
                   // --- End Rewrite for Fixed 4-Week Rule ---

               } else if (selectedView === 'month') {
                    // ... (Month view logic - Ensure UTC parsing/display if needed) ...
                   taskNameHeaderHtml = `<div class="task-name-col border-b font-semibold text-xs text-gray-700 border-r flex items-center justify-center" style="position: sticky; left: 0; background-color: white;">項目</div>`; // Ensure correct class for non-day
                   headerRows = 1;
                   headerGridTemplateRows = 'auto';
                   unitWidth = 120;
                   totalUnits = 0;
                   let monthRowHtml = '';
                   let currentDate = new Date(timelineStartDate);
                   while (currentDate < timelineEndDate) {
                       const year = currentDate.getUTCFullYear();
                       const month = currentDate.getUTCMonth() + 1;
                       monthRowHtml += `<div class="text-center border-b border-r text-sm font-medium text-gray-700 flex items-center justify-center px-2 py-1">${year}/${String(month).padStart(2, '0')}</div>`;
                       columnsStyle += ` ${unitWidth}px`;
                       currentDate.setUTCMonth(currentDate.getUTCMonth() + 1);
                       totalUnits++;
                   }
                   // Ensure the header task name cell is sticky left and has a background
                   taskNameHeaderHtml = `<div class="task-name-col border-b font-semibold text-xs text-gray-700 border-r flex items-center justify-center" style="position: sticky; left: 0; background-color: white;">項目</div>`;
                   headerHtml = taskNameHeaderHtml + monthRowHtml;
               chartWidth = totalUnits * unitWidth;
                   let pxPerDay = chartWidth / diffInDaysUTC(timelineEndDate, timelineStartDate);

                   // Month View Body
                   gridHtml = '';
               for (let i = 0; i <= totalUnits; i++) {
                   gridHtml += `<div class="grid-line" style="left: ${nameColWidth + i * unitWidth -1}px; top: 0; height: ${tasksToRender.length * rowHeight}px;"></div>`;
               }
               bodyHtml += `<div class="relative" style="height: ${tasksToRender.length * rowHeight}px; width: ${nameColWidth + chartWidth}px;">`;
                   bodyHtml += gridHtml;

               tasksToRender.forEach((task, index) => {
                       // Ensure dates are parsed as UTC midnight
                       const taskStartDate = new Date(task.start + 'T00:00:00Z');
                       const taskEndDate = new Date(task.end + 'T00:00:00Z');
                   const startOffsetDays = diffInDaysUTC(taskStartDate, timelineStartDate);
                       const durationDays = diffInDaysUTC(taskEndDate, taskStartDate) + 1;
                       const topPosition = index * rowHeight + (rowHeight - 20) / 2;
                       const leftPosition = nameColWidth + startOffsetDays * pxPerDay;
                       const barWidth = durationDays * pxPerDay - 2;
  
                      bodyHtml += `<div class="task-row-area absolute top-0 left-0 w-full border-b border-gray-200" style="top: ${index * rowHeight}px; height: ${rowHeight}px; z-index: 3;"></div>`;
                   // Remove absolute positioning from inline style, rely on CSS class for sticky
                   bodyHtml += `<div class="task-name-col text-xs text-gray-800 px-2 flex items-center bg-white border-b border-gray-200" style="top: ${index * rowHeight}px; height: ${rowHeight}px; width: ${nameColWidth}px;"><span class="truncate" title="${escapeHtml(task.name)}">${escapeHtml(task.name)}</span></div>`;
  
                       if (barWidth > 0) {
                           const effectiveLeft = Math.max(nameColWidth, leftPosition);
                           const effectiveRight = Math.min(nameColWidth + chartWidth, leftPosition + barWidth);
                           let effectiveWidth = Math.max(0, effectiveRight - effectiveLeft);

                   if (effectiveWidth > 0) {
                       let barContentHtml = '';
                                let barClasses = 'task-bar flex items-center';
                                const escapedInnerText = escapeHtml(task.innerText || '');

                                // --- Apply consistent logic for month view --- 
                                const startStr = `${taskStartDate.getUTCMonth() + 1}/${taskStartDate.getUTCDate()}`;
                                const endStr = `${taskEndDate.getUTCMonth() + 1}/${taskEndDate.getUTCDate()}`;

                                let startHtml = showStartDateInBar ? `<span>${startStr}</span>` : '';
                                let endHtml = showEndDateInBar ? `<span>${endStr}</span>` : '';
                                let innerHtml = escapedInnerText ? `<span class="flex-grow text-center px-1 truncate">${escapedInnerText}</span>` : '<span class="flex-grow"></span>'; // Placeholder if no inner text

                                // Always use flex container, content adjusts based on flags
                                barClasses = 'task-bar flex items-center'; // Ensure base class
                                           barContentHtml = `
                                               <span class="flex justify-between items-center w-full h-full text-white text-[9px] overflow-hidden whitespace-nowrap px-1">
                                      ${startHtml}
                                      ${innerHtml}
                                      ${endHtml}
                                               </span>`;
                                // --- End consistent logic block --- 

                       bodyHtml += `<div class="${barClasses}"
                                  title="${escapeHtml(task.name)}: ${task.start} ~ ${task.end}"
                                   style="top: ${topPosition}px; left: ${effectiveLeft}px; width: ${effectiveWidth}px; z-index: 6; background-color: ${task.color || '#3B82F6'};">
                                       ${barContentHtml}
                              </div>`;
                           }
                       }
                   });
                   bodyHtml += '</div>';
               }

             // --- Final Append --- 
             const headerContainer = document.createElement('div');
              headerContainer.className = 'timeline-header grid border-t'; // Added border-t
             headerContainer.style.gridTemplateColumns = `${nameColWidth}px${columnsStyle}`;
             headerContainer.style.width = `${nameColWidth + chartWidth}px`;
             if(headerRows > 1) headerContainer.style.gridTemplateRows = headerGridTemplateRows;
             headerContainer.innerHTML = headerHtml;

             const bodyContainer = document.createElement('div');
             bodyContainer.className = 'relative'; // Keep relative for absolute positioned children
             bodyContainer.style.width = `${nameColWidth + chartWidth}px`;
             // Important: Inner content (weekend/grid/bars) goes INSIDE the body container
             bodyContainer.innerHTML = bodyHtml;

             console.log('--- Appending header and body containers ---'); // Log before append
               ganttChartDiv.appendChild(headerContainer);
               ganttChartDiv.appendChild(bodyContainer);

             // --- Dynamically set timeline header top based on title height --- 
             // Defer calculation slightly to ensure rendering is complete
             requestAnimationFrame(() => {
                 try {
                     const titleElement = document.getElementById('chart-area-title');
                     const timelineHeaderElement = ganttChartDiv.querySelector('.timeline-header');
                     if (titleElement && timelineHeaderElement) {
                         const titleHeight = titleElement.offsetHeight;
                         // Check if titleHeight is reasonable (not 0)
                         if (titleHeight > 0) {
                            timelineHeaderElement.style.top = `${titleHeight}px`;
                            console.log(`(RAF) Set timeline header top to: ${titleHeight}px`);
                         } else {
                            console.warn('Title height calculated as 0, header top not adjusted.');
                         }
                     } else {
                          console.warn('(RAF) Could not find title or timeline header element to adjust top position.');
                     }
                 } catch (error) {
                      console.error('(RAF) Error adjusting timeline header top:', error);
                 }
             });
             // --- End dynamic top adjustment ---

             // Render task list (always do this)
            renderTaskList();
             console.log('--- renderGanttChart END ---'); // Log End
        }

        function updateProjectName() {
            const projectName = projectNameInput.value.trim();
            const defaultPageTitle = "工程表"; // Changed: Removed "簡易"
            const defaultChartTitle = "工程表"; // Base title for the chart area h2

            // Update chart area title (h2)
            ganttTitleElement.textContent = projectName ? `${projectName} ${defaultChartTitle}` : defaultChartTitle;

            // Update page title (document.title) for print filename suggestion
            document.title = projectName ? `${projectName} ${defaultPageTitle}` : defaultPageTitle;

            localStorage.setItem('ganttProjectName', projectName);
            adjustStickyTitlePosition(); // タイトル更新後にも位置調整
        }

        function loadProjectName() {
            const savedProjectName = localStorage.getItem('ganttProjectName') || '';
            projectNameInput.value = savedProjectName;
            updateProjectName(); // Set initial title based on saved name
        }

        // 工程表タイトルの固定位置を調整する処理を修正
        function adjustStickyTitlePosition() {
            // const header = document.querySelector('header'); // headerの高さは不要になった
            const titleElement = document.getElementById('chart-area-title');
            const timelineHeaderElement = ganttChartDiv.querySelector('.timeline-header');
            const mainElement = document.querySelector('#main-layout-container > main'); // main要素を取得

            if (!titleElement || !mainElement) return; // 必要な要素のみチェック

            // const headerHeight = header.offsetHeight; // 不要になった
            const mainClientWidth = mainElement.clientWidth; // main要素の実際の描画幅を取得
            const titleHeight = titleElement.offsetHeight; // タイトルの高さを取得 (これは必要)

            // タイトルのTopとLeftを調整 (main要素の左上端基準に)
            titleElement.style.position = 'sticky';
            titleElement.style.top = `0px`; // 変更: main要素の上端に固定
            titleElement.style.left = `0px`;
            titleElement.style.width = 'auto';
            titleElement.style.maxWidth = `${mainClientWidth}px`;
            titleElement.style.zIndex = '10'; // z-indexを確認

            // タイムラインヘッダーのTopとLeftも調整 (タイトルの下、main要素の左端基準に)
            if (timelineHeaderElement) {
                timelineHeaderElement.style.position = 'sticky';
                timelineHeaderElement.style.top = `${titleHeight}px`; // 変更: タイトルの高さ分だけ下にずらす
                timelineHeaderElement.style.left = `0px`;
                timelineHeaderElement.style.zIndex = '9'; // z-indexを確認
            }
        }

        // Initial load
        loadProjectName(); // Added: Load project name on page load
        renderGanttChart(); // renderGanttChart の中で adjustStickyTitlePosition が呼ばれるように変更したのでここでは削除
        // 日付表示チェックボックスの初期状態設定
        showStartDateCheckbox.checked = showStartDateInBar;
        showEndDateCheckbox.checked = showEndDateInBar;
        updateHolidayCheckboxState(); // 祝日チェックボックスの初期状態も設定

        // 初回読み込み時に祝日表示がオンならデータを取得
        if (showHolidays) {
            fetchHolidays().then(() => {
                renderGanttChart(); // データ取得後に再描画
            });
        }

        // Initial setup for the 'Show Dates' checkbox state
        updateShowDatesCheckboxState();

        // ページ読み込み時とウィンドウリサイズ時に調整を実行
        window.addEventListener('load', adjustStickyTitlePosition);
        window.addEventListener('resize', adjustStickyTitlePosition);

        // renderGanttChart の最後に adjustStickyTitlePosition を呼び出すように変更
        // 既存の renderGanttChart 関数の一番最後に以下を追加します
        const originalRenderGanttChart = renderGanttChart;
        renderGanttChart = function() {
            originalRenderGanttChart.apply(this, arguments);
            requestAnimationFrame(adjustStickyTitlePosition);
        }

        // --- ★★★ 新しいプロジェクト関連関数 ★★★ ---

        // プロジェクトリストをドロップダウンに描画する関数
        function renderProjectDropdown() {
            const lastSelectedIdStr = localStorage.getItem('lastSelectedProjectId'); // IDは文字列で保存されている可能性がある
            projectSelect.innerHTML = '<option value="">-- プロジェクトを選択 --</option>'; // クリア

            // savedProjectsを名前でソートしてから表示（オプション）
            savedProjects.sort((a, b) => (a.name || '').localeCompare(b.name || ''));

            savedProjects.forEach(project => {
                const option = document.createElement('option');
                option.value = project.id; // valueはID (数値でも文字列でもOK)
                option.textContent = project.name || `プロジェクト ${project.id}`; // 名前がなければID表示
                // lastSelectedIdStr が null でなく、project.id と一致するか比較
                if (lastSelectedIdStr !== null && project.id.toString() === lastSelectedIdStr) {
                    option.selected = true; // 前回選択したものを選択状態に
                }
                projectSelect.appendChild(option);
            });
             // 新規プロジェクト状態を示すオプション（選択できないように）
             if (currentProjectId === null && projectNameInput.value.trim()) { // 名前が入力されている場合のみ「新規: 名前」
                 const newOption = document.createElement('option');
                 newOption.value = "new"; // 特殊な値
                 newOption.textContent = `（新規: ${projectNameInput.value.trim()}）`;
                 newOption.selected = true;
                 newOption.disabled = true; // 選択はできない
                 projectSelect.appendChild(newOption);
             } else if (currentProjectId === null) {
                 // 新規で名前も空の場合
                 const newOption = document.createElement('option');
                 newOption.value = "new";
                 newOption.textContent = '（新規プロジェクト）';
                 newOption.selected = true;
                 newOption.disabled = true;
                 projectSelect.appendChild(newOption);
             }

            // 削除ボタンの状態更新
            // deleteProjectBtn.disabled = !currentProjectId;
        }

        // 指定されたIDのプロジェクトを読み込む関数
        function loadProject(projectId) {
            console.log(`loadProject called with ID: ${projectId} (type: ${typeof projectId})`); // デバッグログ追加
            if (projectId === null || projectId === undefined || projectId === "") {
                // プロジェクト選択解除時（空のプロジェクト表示）
                tasks = [];
                projectNameInput.value = '';
                currentProjectId = null;
                localStorage.removeItem('lastSelectedProjectId'); // 選択解除したのでキーも削除
                document.title = "工程表"; // デフォルトタイトル
                ganttTitleElement.textContent = "工程表";
                console.log("プロジェクト選択解除");
            } else {
                 // projectIdが文字列の場合、数値に変換を試みる
                 const targetId = typeof projectId === 'string' ? parseInt(projectId, 10) : projectId;
                 if (isNaN(targetId)) {
                     console.error(`無効なプロジェクトIDです: ${projectId}`);
                     loadProject(null); // 無効ならクリア
                     return;
                 }

                const project = savedProjects.find(p => p.id === targetId); // 数値IDで検索
                if (project) {
                     // tasks 配列をディープコピーして読み込む（重要：元の配列を変更しないため）
                     tasks = project.tasks ? JSON.parse(JSON.stringify(project.tasks)) : [];
                     projectNameInput.value = project.name || '';
                     currentProjectId = project.id; // number型で保持
                     localStorage.setItem('lastSelectedProjectId', currentProjectId.toString()); // 文字列で保存
                     console.log(`プロジェクト読み込み: ID=${currentProjectId}, Name=${project.name}`);
                     // プロジェクト名に基づきタイトル更新
                     updateProjectName();
                 } else {
                     console.error(`プロジェクトID ${targetId} が見つかりません。`);
                     // 見つからない場合は最後に選択したIDを削除し、クリア
                     localStorage.removeItem('lastSelectedProjectId');
                     loadProject(null); // クリア
                     return; // ここで処理終了
                 }
             }
             // tasks 配列の order プロパティを再計算/ソート (loadProject 後に必須)
             initializeTaskOrder();
             // 工程表とタスクリストを再描画
             renderGanttChart();
             // ドロップダウンの状態も更新
             renderProjectDropdown();
         }

        // tasks 配列の order プロパティを初期化/ソートする関数
        function initializeTaskOrder() {
            let maxOrder = 0;
            tasks.forEach((task, index) => {
                 if (task.order === undefined || task.order === null || typeof task.order !== 'number' || task.order <= 0) {
                     task.order = index + 1; // 不正な値や欠損の場合はインデックスで割り当て
                 }
                 if (task.order > maxOrder) {
                     maxOrder = task.order;
                 }
             });
            // 連番になっていない可能性があるので、ソート後に再採番する
            tasks.sort((a, b) => (a.order ?? Infinity) - (b.order ?? Infinity));
            tasks.forEach((task, index) => {
                task.order = index + 1;
            });
            // maxOrder はここでは不要なので更新しない
        }

        // localStorageから全プロジェクトデータを読み込む関数
        function loadAllProjects() {
            const storedProjects = localStorage.getItem('savedProjects');
            if (storedProjects) {
                try {
                    savedProjects = JSON.parse(storedProjects);
                    // 簡単なバリデーション (配列か、各要素にid(数値)があるか)
                    if (!Array.isArray(savedProjects) || !savedProjects.every(p => p && typeof p.id === 'number')) {
                        console.warn("LocalStorageのsavedProjectsデータ形式が不正です。リセットします。");
                        savedProjects = [];
                        localStorage.removeItem('savedProjects');
                        localStorage.removeItem('lastSelectedProjectId');
                    }
                } catch (e) {
                    console.error("LocalStorageからのプロジェクト読み込みに失敗しました:", e);
                    savedProjects = [];
                    localStorage.removeItem('savedProjects');
                    localStorage.removeItem('lastSelectedProjectId');
                }
            } else {
                savedProjects = []; // データがなければ空配列
            }
             console.log("全プロジェクト読み込み完了:", savedProjects);
        }

        // 全プロジェクトデータをlocalStorageに保存する関数
        function saveAllProjects() {
            try {
                localStorage.setItem('savedProjects', JSON.stringify(savedProjects));
                 console.log("全プロジェクト保存完了:", savedProjects);
            } catch (e) {
                console.error("LocalStorageへのプロジェクト保存に失敗しました:", e);
                alert("プロジェクトの保存に失敗しました。LocalStorageの容量を確認してください。");
            }
        }
        // --- ★★★ ここまで追加 ★★★ ---

        // --- Event Listeners ---
        taskForm.addEventListener('submit', (event) => {
             // ... (タスク追加処理はほぼ変更なし、ただし maxOrder の扱いが変わる) ...
             event.preventDefault();
             const taskName = taskNameInput.value.trim();
             const startDate = startDateInput.value;
             const endDate = endDateInput.value;
             const taskColor = taskColorInput.value;
             const innerText = innerTextInput.value.trim();
             if (!taskName || !startDate || !endDate) { alert('全ての項目を入力してください。'); return; }
             if (new Date(startDate) > new Date(endDate)) { alert('終了日は開始日以降に設定してください。'); return; }

             // 現在の tasks 配列から最大の order を取得
             let currentMaxOrder = 0;
             tasks.forEach(task => {
                 if (typeof task.order === 'number' && task.order > currentMaxOrder) {
                     currentMaxOrder = task.order;
                 }
             });
             const newOrder = currentMaxOrder + 1;

             const newTask = {
                 id: Date.now() + Math.random(), // タスクIDはよりユニークにするため乱数を加える
                 name: taskName,
                 start: startDate,
                 end: endDate,
                 color: taskColor,
                 innerText: innerText,
                 order: newOrder // 新しい order を割り当て
             };
             tasks.push(newTask);
             // initializeTaskOrder(); // 追加直後にソート＆再採番は不要かも

             taskForm.reset();
             innerTextInput.value = '';
             taskColorInput.value = "#3B82F6";
             // ★★★ 変更点: タスク追加後、すぐに保存はしないが、UIは更新 ★★★
             renderGanttChart(); // これで renderTaskList も呼ばれる
             // ★★★ ここまで変更 ★★★

            // if (taskListContent.classList.contains('hidden')) {
            //     // toggleTaskList(); // toggleTaskList は renderTaskList 内で処理されるように変更？ (確認)
            // }
        });

        // ★★★ 新しいUI要素のイベントリスナーを追加 ★★★
        projectSelect.addEventListener('change', (event) => {
            const selectedId = event.target.value;
            if (selectedId && selectedId !== "new") {
                // ★変更: 保存されていない変更があるか確認する (オプション)
                // if (hasUnsavedChanges()) { // ← hasUnsavedChanges() は別途実装が必要
                //     if (!confirm("変更が保存されていません。移動しますか？")) {
                //         projectSelect.value = currentProjectId !== null ? currentProjectId.toString() : ""; // 選択を元に戻す
                //         return;
                //     }
                // }
                loadProject(selectedId);
            } else if (selectedId === "") {
                // ★変更: 保存されていない変更があるか確認する (オプション)
                // if (hasUnsavedChanges()) { ... }
                loadProject(null);
            }
            // "new" の場合は何もしない（表示のみ）
        });

        // ★★★ 新規作成ボタンのリスナー ★★★
        createNewProjectBtn.addEventListener('click', () => {
            // ★変更: 保存されていない変更があるか確認する (オプション)
            // if (hasUnsavedChanges()) { ... }

            console.log("新規プロジェクト作成ボタンクリック");
            tasks = []; // タスクを空にする
            projectNameInput.value = ''; // プロジェクト名入力欄を空にする
            currentProjectId = null; // 現在のプロジェクトIDをnullにする
            localStorage.removeItem('lastSelectedProjectId'); // 最後に選択したIDもクリア
            initializeTaskOrder(); // tasks が空なので不要かもしれないが一応呼ぶ
            renderGanttChart(); // 空のチャートを描画
            renderProjectDropdown(); // ドロップダウンを「（新規プロジェクト）」表示に更新
            projectNameInput.focus(); // プロジェクト名入力欄にフォーカス
        });

        // ★★★ 保存ボタンのリスナー ★★★
        saveProjectBtn.addEventListener('click', () => {
            const projectName = projectNameInput.value.trim();
            if (!projectName) {
                alert("プロジェクト名を入力してください。");
                projectNameInput.focus();
                return;
            }

            // ディープコピーして保存する (重要！)
            const tasksToSave = JSON.parse(JSON.stringify(tasks));

            if (currentProjectId !== null) {
                // --- 既存プロジェクトの上書き保存 ---
                const projectIndex = savedProjects.findIndex(p => p.id === currentProjectId);
                if (projectIndex !== -1) {
                    savedProjects[projectIndex].name = projectName;
                    savedProjects[projectIndex].tasks = tasksToSave;
                    console.log(`既存プロジェクト上書き保存: ID=${currentProjectId}, Name=${projectName}`);
                } else {
                    // IDがあるのに配列に見つからない場合（通常はないはずだが念のため）
                    console.error(`保存エラー: ID ${currentProjectId} のプロジェクトが見つかりません。新規として保存しますか？`);
                     // 新規保存として扱うか、エラー処理をするか選択
                     // ここでは新規保存として扱う（IDは再生成）
                     currentProjectId = null;
                }
            }

            if (currentProjectId === null) {
                // --- 新規プロジェクトの保存 ---
                if (savedProjects.length >= 10) {
                    alert("保存できるプロジェクトは最大10個までです。");
                    return;
                }
                const newProjectId = Date.now(); // 新しいIDを生成 (Unixtimeミリ秒)
                const newProject = {
                    id: newProjectId,
                    name: projectName,
                    tasks: tasksToSave
                };
                savedProjects.push(newProject);
                currentProjectId = newProjectId; // 保存したのでIDを設定
                localStorage.setItem('lastSelectedProjectId', currentProjectId.toString()); // 最後に選択したIDとして保存
                console.log(`新規プロジェクト保存: ID=${currentProjectId}, Name=${projectName}`);
            }

            saveAllProjects(); // localStorageに全プロジェクトを保存
            renderProjectDropdown(); // ドロップダウンを更新 (新しい名前や選択状態を反映)
            // 保存成功のメッセージ（オプション）
            // alert(`プロジェクト「${projectName}」を保存しました。`);
        });

        // ★★★ 削除ボタンのリスナー ★★★
        // deleteProjectBtn.addEventListener('click', () => { ... });

        // projectNameInput の input リスナー (必要)
        if (projectNameInput) {
            projectNameInput.addEventListener('input', () => {
                updateProjectName(); // 入力中にタイトルを更新
                if (currentProjectId === null) {
                    renderProjectDropdown(); // 新規編集中であることをドロップダウンに反映
                }
            });
        } else {
             console.error("projectNameInput element not found during event listener setup.");
        }

        // --- Core Functions ---
        function deleteTask(taskId) {
            const taskToDelete = tasks.find(task => task.id === taskId);
            const taskName = taskToDelete ? escapeHtml(taskToDelete.name) : 'このタスク';
            if (confirm(`「${taskName}」を削除しますか？`)) {
                tasks = tasks.filter(task => task.id !== taskId);
                initializeTaskOrder(); // 削除後、順番を再採番
                renderGanttChart(); // 再描画
            }
        }

        // saveTasks 関数は saveAllProjects に統合されるためコメントアウトまたは削除
        // function saveTasks() { ... }

        function handleTaskUpdate(event) {
             const input = event.target;
             const row = input.closest('div[data-task-id]');
             if (!row || !row.dataset.taskId) { console.error('Update failed: Could not find task ID from row.'); return; }
             const taskIdStr = row.dataset.taskId; // IDは文字列かもしれない
             const field = input.dataset.field;
             if (!field) { console.error('Update failed: Input is missing data-field attribute.'); return; }

            let newValue = input.value;
            // taskId を数値に変換して比較 (task.id も数値のはず)
            const taskId = parseFloat(taskIdStr); // parseFloatでも良い
            const taskIndex = tasks.findIndex(t => t.id === taskId);
            if (taskIndex === -1) { console.error(`Update failed: Task with ID ${taskId} not found.`); return; }
            const oldValue = tasks[taskIndex][field];

             // --- Validation (変更なし) ---
             if (field === 'start' || field === 'end') {
                 const startDate = field === 'start' ? newValue : tasks[taskIndex].start;
                 const endDate = field === 'end' ? newValue : tasks[taskIndex].end;
                 const startDt = new Date(startDate); const endDt = new Date(endDate);
                 if (isNaN(startDt.getTime()) || isNaN(endDt.getTime())) { alert('無効な日付形式です。'); input.value = oldValue; return; }
                 if (startDt > endDt) { alert('終了日は開始日以降に設定してください。'); input.value = oldValue; return; }
             } else if (field === 'name' && newValue.trim() === '') {
                  alert('項目名は空にできません。'); input.value = oldValue; return;
              } else if (field === 'innerText') {
                  // No validation needed for empty string
              }
              // orderのバリデーションは再採番ロジック内で行う

            // --- Update data ---
            // order 以外の場合はここで更新
             if (field !== 'order') {
                 tasks[taskIndex][field] = newValue;
             }

            // --- 再採番ロジック (order 変更時) ---
             if (field === 'order') {
                 const numValue = parseInt(newValue, 10);
                 if (isNaN(numValue) || numValue < 1) {
                      alert('順番には1以上の数値を入力してください。');
                      input.value = oldValue ?? '';
                      return; // 再描画せず入力値を元に戻す
                  }
                  newValue = numValue; // Use the parsed number

                  // 入力された順番が現在のタスク数を超える場合は、タスク数に丸める
                  if (newValue > tasks.length) {
                      newValue = tasks.length;
                      input.value = newValue; // 入力フィールドも更新
                  }

                 // 対象タスクを一時的に保持
                 const targetTask = tasks[taskIndex];

                 // 現在の順番と同じ場合は何もしない
                 if (targetTask.order === newValue) {
                     return;
                 }

                 // 現在の位置から削除
                 tasks.splice(taskIndex, 1);
                 // 新しい位置に挿入 (spliceの第1引数は0始まりのindexなのでnewValue-1)
                 tasks.splice(newValue - 1, 0, targetTask);
                 // 全てのタスクに1から順番を再割り当て
                 tasks.forEach((task, index) => {
                     task.order = index + 1;
                 });

                 renderGanttChart(); // ガントチャートとリストを更新 (リスト内の値も更新される)
                 return; // 再描画されたので以降の処理は不要
             }

             // order 以外の更新の場合、または再採番ロジックを通らなかった場合
             renderGanttChart(); // UIを更新
         }

        function renderTaskList() {
            const focusedElement = document.activeElement; let focusedTaskId = null; let focusedField = null;

            // Keep track of which accordions are open
            const openAccordionIds = new Set();
            // taskListContent が存在するか確認
            if (taskListContent) {
                taskListContent.querySelectorAll('.task-details:not(.hidden)').forEach(el => {
                    openAccordionIds.add(el.id);
                });

                // Determine focused element before clearing
                if (taskListContent.contains(focusedElement) && focusedElement.tagName === 'INPUT' && focusedElement.closest('div[data-task-id]') && focusedElement.dataset.field) {
                   focusedTaskId = focusedElement.closest('div[data-task-id]').dataset.taskId;
                   focusedField = focusedElement.dataset.field;
                }

                taskListContent.innerHTML = ''; // Clear previous list content
            } else {
                 console.error("taskListContent element not found during renderTaskList.");
                 return; // taskListContent がなければ処理中断
            }


            if (tasks.length === 0) {
                const p = document.createElement('p');
                p.className = 'text-gray-500 text-sm';
                p.textContent = 'タスクはまだありません。';
                taskListContent.appendChild(p);
                return;
            }

             tasks.forEach(task => {
                const taskDiv = document.createElement('div');
                taskDiv.className = 'border-b border-gray-200 py-2 space-y-1 text-xs'; // Container for one task
                taskDiv.dataset.taskId = task.id; // Use task.id (should be number or string convertible to number)
                const inputIdBase = `list-task-${task.id}`;
                const defaultColor = task.color || '#3B82F6';

                // --- Row 1: Toggle, Order and Name ---
                const row1 = document.createElement('div');
                row1.className = 'flex items-center gap-1';

                // Accordion Toggle Button
                const toggleButton = document.createElement('button');
                toggleButton.type = 'button';
                toggleButton.className = 'task-list-toggle p-0 mr-1 flex-shrink-0'; // Use existing toggle style base
                toggleButton.setAttribute('aria-expanded', 'false'); // Accessibility
                toggleButton.setAttribute('aria-controls', `task-details-${task.id}`); // Accessibility
                toggleButton.dataset.target = `#task-details-${task.id}`;
                toggleButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-chevron-down transition-transform duration-200"><path d="m6 9 6 6 6-6"/></svg>`;
                row1.appendChild(toggleButton);

                // Order Input
                 const inputOrder = document.createElement('input');
                 inputOrder.type = 'number';
                 inputOrder.id = `${inputIdBase}-order`;
                 inputOrder.value = task.order ?? ''; // order が null/undefined なら空文字
                 inputOrder.dataset.taskId = task.id; // Use task.id
                 inputOrder.dataset.field = 'order';
                 inputOrder.className = 'border rounded px-1 py-0.5 text-xs w-8 text-center'; // Adjusted width and centered text
                 inputOrder.min = "1";
                row1.appendChild(inputOrder);

                // Name Input
                const inputName = document.createElement('input');
                inputName.type = 'text';
                inputName.id = `${inputIdBase}-name`;
                inputName.value = task.name || ''; // name が falsy なら空文字
                inputName.dataset.taskId = task.id; // Use task.id
                inputName.dataset.field = 'name';
                inputName.className = 'flex-grow border rounded px-1 py-0.5 text-xs min-w-0'; // Grow and allow shrinking
                row1.appendChild(inputName);

                // --- Details Container (Hidden by default) ---
                const detailsDiv = document.createElement('div');
                detailsDiv.id = `task-details-${task.id}`;
                detailsDiv.className = 'task-details hidden space-y-1 mt-1 pl-5'; // pl-5 for indentation

                // --- Row 2: Start Date and End Date ---
                const row2 = document.createElement('div');
                row2.className = 'grid grid-cols-2 gap-1'; // Use grid for dates

                // Start Date
                const startDiv = document.createElement('div');
                const startLabel = document.createElement('label');
                startLabel.htmlFor = `${inputIdBase}-start`;
                startLabel.className = 'block text-[10px] text-gray-600';
                startLabel.textContent = '開始';
                const inputStart = document.createElement('input');
                inputStart.type = 'date';
                inputStart.id = `${inputIdBase}-start`;
                inputStart.value = task.start || ''; // date が falsy なら空文字
                inputStart.dataset.taskId = task.id; // Use task.id
                inputStart.dataset.field = 'start';
                inputStart.className = 'w-full border rounded px-1 py-0.5 text-xs font-normal';
                inputStart.style.fontSize = '0.65rem';
                startDiv.appendChild(startLabel);
                startDiv.appendChild(inputStart);
                row2.appendChild(startDiv);

                // End Date
                const endDiv = document.createElement('div');
                const endLabel = document.createElement('label');
                endLabel.htmlFor = `${inputIdBase}-end`;
                endLabel.className = 'block text-[10px] text-gray-600';
                endLabel.textContent = '終了';
                const inputEnd = document.createElement('input');
                inputEnd.type = 'date';
                inputEnd.id = `${inputIdBase}-end`;
                inputEnd.value = task.end || ''; // date が falsy なら空文字
                inputEnd.dataset.taskId = task.id; // Use task.id
                inputEnd.dataset.field = 'end';
                inputEnd.className = 'w-full border rounded px-1 py-0.5 text-xs font-normal';
                inputEnd.style.fontSize = '0.65rem';
                endDiv.appendChild(endLabel);
                endDiv.appendChild(inputEnd);
                row2.appendChild(endDiv);

                detailsDiv.appendChild(row2); // Add row 2 to details div

                // Row 4: バー内文字
                const row4 = document.createElement('div');
                row4.className = 'mt-1';
                const innerTextLabel = document.createElement('label');
                innerTextLabel.htmlFor = `${inputIdBase}-innerText`;
                innerTextLabel.className = 'block text-[10px] text-gray-600';
                innerTextLabel.textContent = '内文字';
                const inputInnerText = document.createElement('input');
                inputInnerText.type = 'text';
                inputInnerText.id = `${inputIdBase}-innerText`;
                inputInnerText.value = task.innerText || '';
                inputInnerText.dataset.taskId = task.id; // Use task.id
                inputInnerText.dataset.field = 'innerText';
                inputInnerText.className = 'w-full border rounded px-1 py-0.5 text-xs';
                row4.appendChild(innerTextLabel);
                row4.appendChild(inputInnerText);
                detailsDiv.appendChild(row4);

                // Row 3: Color and Delete Action
                const row3 = document.createElement('div');
                row3.className = 'flex items-center justify-between gap-1 mt-1';

               // Color Picker + Swatch
               const colorDiv = document.createElement('div');
               colorDiv.className = 'flex items-center gap-1';
                const inputColor = document.createElement('input');
                inputColor.type = 'color';
                inputColor.id = `${inputIdBase}-color`;
                inputColor.value = defaultColor;
                inputColor.dataset.taskId = task.id; // Use task.id
                inputColor.dataset.field = 'color';
                inputColor.className = 'border border-gray-300 rounded cursor-pointer w-6 h-5 p-0.5'; // Adjusted size
                const colorSwatch = document.createElement('span');
                colorSwatch.className = 'color-swatch inline-block w-4 h-4 rounded border border-gray-300 align-middle'; // Style is applied via CSS selector
                colorSwatch.style.backgroundColor = defaultColor;
                // クリックでカラーピッカーを開くようにする（オプション）
                 colorSwatch.onclick = () => inputColor.click();
                 colorDiv.appendChild(inputColor);
                 colorDiv.appendChild(colorSwatch);
                row3.appendChild(colorDiv);

                // Delete Button
                const deleteButton = document.createElement('button');
                deleteButton.className = 'delete-btn text-red-500 hover:text-red-600 bg-none border-none p-0 cursor-pointer inline-flex items-center justify-center'; // Style is applied via CSS selector
                deleteButton.title = '削除';
                 // deleteTaskに渡すIDが数値であることを確認
                 deleteButton.onclick = () => deleteTask(task.id);
                deleteButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-trash-2"><path d="M3 6h18"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></svg>`;
                row3.appendChild(deleteButton);

                detailsDiv.appendChild(row3); // Add row 3

                taskDiv.appendChild(row1);      // Append row 1
                taskDiv.appendChild(detailsDiv); // Append details div

                taskListContent.appendChild(taskDiv);

                // Restore open state and set aria-expanded
                const isOpen = openAccordionIds.has(detailsDiv.id);
                if (isOpen) {
                    detailsDiv.classList.remove('hidden');
                    toggleButton.querySelector('svg').classList.add('rotate-180');
                }
                toggleButton.setAttribute('aria-expanded', isOpen.toString());
            });

             // --- Re-attach Event Listeners ---
              const inputs = taskListContent.querySelectorAll('input[data-field]');
              inputs.forEach(input => {
                   // 'input'イベントはリアルタイムすぎる場合があるので'change'や'blur'を適切に使う
                   const eventType = (input.type === 'date' || input.type === 'color' || input.type === 'number') ? 'change' : 'blur';
                   // 既存のリスナーを削除してから追加する（重複防止）
                   input.removeEventListener(eventType, handleTaskUpdate);
                   input.addEventListener(eventType, handleTaskUpdate);

                   if (input.type === 'text' || input.type === 'number') {
                       // Keydownリスナーも同様に重複防止
                       const handleKeyDown = (event) => {
                           if (event.key === 'Enter') {
                               handleTaskUpdate(event); // Blurの前に更新をトリガー
                               event.target.blur();
                           } else if (event.key === 'Escape') {
                              // Escape時は更新せず、元の値に戻す（オプション）
                              const taskId = parseFloat(input.closest('div[data-task-id]').dataset.taskId);
                              const field = input.dataset.field;
                              const task = tasks.find(t => t.id === taskId);
                              if(task) input.value = task[field] || ''; // 元の値に戻す
                              event.target.blur();
                           }
                       };
                       input.removeEventListener('keydown', handleKeyDown);
                       input.addEventListener('keydown', handleKeyDown);
                   }
              });

            // --- Accordion Event Listener (Using Event Delegation, ensure it's attached once) ---
             // This should ideally be outside renderTaskList, attached once on initial load
             // We'll check if it's already attached using a flag.
             if (!taskListContent.dataset.accordionListenerAttached) {
                 taskListContent.addEventListener('click', (event) => {
                     const toggleButton = event.target.closest('.task-list-toggle');
                     if (!toggleButton) return;

                     const targetSelector = toggleButton.dataset.target;
                     if (!targetSelector) return;

                     // Use taskListContent as the base for querySelector to avoid issues
                     const detailsDiv = taskListContent.querySelector(targetSelector);
                     if (!detailsDiv) return;

                     const isOpening = detailsDiv.classList.toggle('hidden');
                     const isOpen = !isOpening;
                     toggleButton.querySelector('svg').classList.toggle('rotate-180', isOpen);
                     toggleButton.setAttribute('aria-expanded', isOpen.toString());
                 });
                 taskListContent.dataset.accordionListenerAttached = 'true'; // Set flag
             }


             // --- Restore Focus ---
              if (focusedTaskId && focusedField) {
                 // IDが文字列になっている可能性があるので、属性セレクタで比較
                 const elementToFocus = taskListContent.querySelector(`[data-task-id='${focusedTaskId}'] [data-field='${focusedField}']`);
                 if (elementToFocus) {
                     setTimeout(() => {
                          try {
                             elementToFocus.focus();
                             // テキスト入力系なら末尾にカーソルを移動
                             if (elementToFocus.select && typeof elementToFocus.select === 'function') {
                                  elementToFocus.select(); // テキスト全選択
                              } else if (elementToFocus.setSelectionRange && typeof elementToFocus.setSelectionRange === 'function') {
                                  const len = elementToFocus.value.length;
                                  elementToFocus.setSelectionRange(len, len); // 末尾にカーソル
                              }
                          } catch (e) {
                              console.warn("Focus/select error:", e);
                          }
                     }, 0); // 少し遅延させてフォーカス
                 }
             }
         }

        function renderGanttChart() {
             console.log('--- renderGanttChart START ---'); // Log Start
             // ganttChartDiv が存在するか確認
             if (!ganttChartDiv) {
                 console.error("ganttChartDiv element not found during renderGanttChart.");
                 renderTaskList(); // タスクリストだけでも描画試行
                 return; // ganttChartDiv がなければ処理中断
             }
             ganttChartDiv.innerHTML = ''; // Clear previous chart

             if (tasks.length === 0) {
                 ganttChartDiv.innerHTML = '<p class="text-gray-500 text-sm px-4">タスクを追加してください。</p>';
                 renderTaskList(); // Still render the (empty) task list
                 updateProjectName(); // タイトル更新
                 adjustStickyTitlePosition(); // 位置調整
                 return;
             }

             const selectedView = document.querySelector('input[name="view-type"]:checked').value;

             // --- Determine overall date range from tasks ---
             let overallMinDateTask, overallMaxDateTask;
             // tasks 配列内の日付文字列を Date オブジェクトに変換して比較
             const validTasksForRange = tasks.map(t => ({
                 start: new Date(t.start + 'T00:00:00Z'), // Parse as UTC midnight
                 end: new Date(t.end + 'T00:00:00Z')     // Parse as UTC midnight
             })).filter(t => !isNaN(t.start.getTime()) && !isNaN(t.end.getTime())); // Filter out invalid dates

             if (validTasksForRange.length > 0) {
                 overallMinDateTask = new Date(validTasksForRange[0].start);
                 overallMaxDateTask = new Date(validTasksForRange[0].end);
                 validTasksForRange.forEach(task => {
                     if (task.start < overallMinDateTask) overallMinDateTask = task.start;
                     if (task.end > overallMaxDateTask) overallMaxDateTask = task.end;
                 });
             } else {
                 // No valid tasks, set a default range (e.g., this month in UTC)
                 const today = new Date();
                 overallMinDateTask = new Date(Date.UTC(today.getUTCFullYear(), today.getUTCMonth(), 1));
                 overallMaxDateTask = new Date(Date.UTC(today.getUTCFullYear(), today.getUTCMonth() + 1, 0));
             }

             // --- Determine effective display period (user specified or default) ---
             let effectiveMinDate, effectiveMaxDate;
             let isPeriodSpecified = false;
             if (displayStartDate && displayEndDate) {
                 effectiveMinDate = new Date(displayStartDate + 'T00:00:00Z');
                 effectiveMaxDate = new Date(displayEndDate + 'T00:00:00Z');
                 if (isNaN(effectiveMinDate.getTime()) || isNaN(effectiveMaxDate.getTime())) {
                     console.warn("Invalid display period dates, using task range.");
                     effectiveMinDate = new Date(overallMinDateTask);
                     effectiveMaxDate = new Date(overallMaxDateTask);
                 } else if (effectiveMinDate > effectiveMaxDate) {
                     [effectiveMinDate, effectiveMaxDate] = [effectiveMaxDate, effectiveMinDate]; // Swap
                     isPeriodSpecified = true;
                 } else {
                     isPeriodSpecified = true;
                 }
             } else {
                 effectiveMinDate = new Date(overallMinDateTask);
                 effectiveMaxDate = new Date(overallMaxDateTask);
             }

             // --- Timeline boundaries ---
             let timelineStartDate, timelineEndDate;

             // --- Initialize common variables ---
             let headerHtml = '';
             let bodyHtml = '';
             let gridHtml = '';
             let totalUnits = 0;
             let unitWidth = 0;
             let chartWidth = 0;
             let headerRows = 1;
             let headerGridTemplateRows = 'auto';
             let columnsStyle = '';
             const nameColWidth = 180;
             const rowHeight = 35;
             let taskNameHeaderHtml = `<div class="task-name-col font-semibold text-xs text-gray-700 border-r flex items-center justify-center">項目</div>`;

             // --- Calculate timeline boundaries based on view type ---
             if (selectedView === 'week') {
                 timelineStartDate = getStartOfMonth(effectiveMinDate);
                 timelineEndDate = new Date(Date.UTC(effectiveMaxDate.getUTCFullYear(), effectiveMaxDate.getUTCMonth() + 1, 1));
             } else if (selectedView === 'month') {
                 timelineStartDate = getStartOfMonth(effectiveMinDate);
                 timelineEndDate = new Date(Date.UTC(effectiveMaxDate.getUTCFullYear(), effectiveMaxDate.getUTCMonth() + 1, 1));
             } else { // day
                 timelineStartDate = new Date(effectiveMinDate);
                 timelineEndDate = new Date(effectiveMaxDate);
                 timelineEndDate.setUTCDate(timelineEndDate.getUTCDate() + 1); // Make end date exclusive
                 if (!isPeriodSpecified) {
                     timelineStartDate.setUTCDate(timelineStartDate.getUTCDate() - 2);
                     timelineEndDate.setUTCDate(timelineEndDate.getUTCDate() + 3);
                 }
             }

             // --- Filter tasks to render based on effective period ---
             const tasksToRender = tasks.filter(task => {
                 try {
                     const taskStart = new Date(task.start + 'T00:00:00Z');
                     const taskEnd = new Date(task.end + 'T00:00:00Z');
                     return taskEnd >= effectiveMinDate && taskStart <= effectiveMaxDate;
                 } catch (e) {
                     return false;
                 }
             });

             if (tasksToRender.length === 0 && tasks.length > 0) {
                 ganttChartDiv.innerHTML = '<p class="text-gray-500 text-sm px-4">指定された期間に該当するタスクはありません。</p>';
                 renderTaskList();
                 updateProjectName();
                 adjustStickyTitlePosition();
                 return;
             } else if (tasks.length === 0) {
                 // Already handled at the beginning
                 return;
             }

             // --- Generate Chart Header and Body based on View Type ---
             if (selectedView === 'day') {
                 taskNameHeaderHtml = `<div class="task-name-col task-name-col-header font-semibold text-xs text-gray-700 border-b border-r flex items-center justify-center" style="position: sticky; left: 0; background-color: white;">項目</div>`;
                 headerRows = 2;
                 headerGridTemplateRows = 'auto auto';
                 unitWidth = 30;
                 totalUnits = diffInDaysUTC(timelineEndDate, timelineStartDate);
                 let weekendBackgroundHtml = '<div class="absolute top-0 left-0 w-full h-full" style="z-index: 2;">';
                 let yearRowHtml = '';
                 let dayRowHtml = '';
                 let currentYear = -1;
                 let yearStartColIndex = 2;
                 let currentDate = new Date(timelineStartDate);

                 while (currentDate < timelineEndDate) {
                     const year = currentDate.getUTCFullYear();
                     const colIndex = diffInDaysUTC(currentDate, timelineStartDate) + 2;

                     if (year !== currentYear) {
                         if (currentYear !== -1) {
                             const prevYearColSpan = colIndex - yearStartColIndex; // Corrected span calculation
                             const yearBorderStyle = yearStartColIndex === 2 ? '' : 'border-left-width: 1px;';
                             yearRowHtml += `<div class="text-center border-b text-sm font-semibold text-gray-700 flex items-center justify-center" style="grid-row: 1; grid-column: ${yearStartColIndex} / span ${prevYearColSpan}; ${yearBorderStyle}">${currentYear}年</div>`;
                         }
                         currentYear = year;
                         yearStartColIndex = colIndex;
                     }

                     const month = currentDate.getUTCMonth() + 1;
                     const day = currentDate.getUTCDate();
                     const dayOfWeek = ['日','月','火','水','木','金','土'][currentDate.getUTCDay()];
                     let dayClass = 'text-gray-600';
                     let weekendBgClass = '';
                     if (currentDate.getUTCDay() === 0) { dayClass = 'bg-red-50 text-red-700'; weekendBgClass = 'bg-red-50'; }
                     else if (currentDate.getUTCDay() === 6) { dayClass = 'bg-blue-50 text-blue-700'; weekendBgClass = 'bg-blue-50'; }
                     const dateString = formatDate(currentDate);
                     const holidayName = showHolidays ? holidays[dateString] : null;
                     if (holidayName) { dayClass = 'bg-red-100 text-red-800'; weekendBgClass = 'bg-red-100'; }
                     let titleAttr = holidayName ? ` title="${escapeHtml(holidayName)}"` : '';
                     const dayBorderStyle = colIndex === 2 ? '' : 'border-left-width: 1px;';
                     dayRowHtml += `<div class="text-center border-b text-[10px] font-medium ${dayClass} flex flex-col justify-center py-1" style="grid-row: 2; grid-column: ${colIndex}; ${dayBorderStyle}"${titleAttr}><div>${month}/${day}</div><div class="text-[9px]">${dayOfWeek}</div></div>`;
                     if (weekendBgClass) {
                         const bgLeft = nameColWidth + (colIndex - 2) * unitWidth;
                         weekendBackgroundHtml += `<div class="absolute ${weekendBgClass}" style="left: ${bgLeft}px; top: 0; width: ${unitWidth}px; height: ${tasksToRender.length * rowHeight}px;"></div>`;
                     }
                     columnsStyle += ` ${unitWidth}px`;
                     currentDate.setUTCDate(currentDate.getUTCDate() + 1);
                 }
                 if (currentYear !== -1) {
                     // Calculate the span for the final year
                     const finalYearColSpan = totalUnits - (yearStartColIndex - 2); // Corrected span calculation
                     const finalYearBorderStyle = yearStartColIndex === 2 ? '' : 'border-left-width: 1px;';
                     yearRowHtml += `<div class="text-center border-b text-sm font-semibold text-gray-700 flex items-center justify-center" style="grid-row: 1; grid-column: ${yearStartColIndex} / span ${finalYearColSpan}; ${finalYearBorderStyle}">${currentYear}年</div>`;
                 }
                 weekendBackgroundHtml += '</div>';
                 headerHtml = taskNameHeaderHtml + yearRowHtml + dayRowHtml;
                 chartWidth = totalUnits * unitWidth;

                 let pxPerDay = unitWidth;

                 // --- Day View Body Generation ---
                 gridHtml = '';
                 for (let i = 1; i <= totalUnits; i++) { // Loop starts from 1
                     gridHtml += `<div class="grid-line" style="left: ${nameColWidth + i * unitWidth}px; top: 0; height: ${tasksToRender.length * rowHeight}px;"></div>`;
                 }
                 bodyHtml += `<div class="relative" style="height: ${tasksToRender.length * rowHeight}px; width: ${nameColWidth + chartWidth}px;">`;
                 bodyHtml += gridHtml;
                 bodyHtml += weekendBackgroundHtml;

                 tasksToRender.forEach((task, index) => {
                     const taskStartDate = new Date(task.start + 'T00:00:00Z');
                     const taskEndDate = new Date(task.end + 'T00:00:00Z');
                     const startOffsetDays = diffInDaysUTC(taskStartDate, timelineStartDate);
                     const durationDays = diffInDaysUTC(taskEndDate, taskStartDate) + 1;
                     const topPosition = index * rowHeight + (rowHeight - 20) / 2;
                     const leftPosition = nameColWidth + startOffsetDays * pxPerDay;
                     const barWidth = durationDays * pxPerDay - 2; // -2 for padding

                     bodyHtml += `<div class="task-row-area absolute top-0 left-0 w-full border-b border-gray-200" style="top: ${index * rowHeight}px; height: ${rowHeight}px; z-index: 3;"></div>`;
                     bodyHtml += `<div class="task-name-col text-xs text-gray-800 px-2 flex items-center bg-white border-b border-gray-200" style="top: ${index * rowHeight}px; height: ${rowHeight}px; width: ${nameColWidth}px;"><span class="truncate" title="${escapeHtml(task.name)}">${escapeHtml(task.name)}</span></div>`;

                     if (barWidth > 0) {
                         const effectiveLeft = Math.max(nameColWidth, leftPosition);
                         const effectiveRight = Math.min(nameColWidth + chartWidth, leftPosition + barWidth);
                         let effectiveWidth = Math.max(0, effectiveRight - effectiveLeft);

                         if (effectiveWidth > 0) {
                             let barContentHtml = '';
                             let barClasses = 'task-bar flex items-center';
                             const taskInnerText = task.innerText || '';
                             const escapedInnerText = escapeHtml(taskInnerText);
                             const startStr = `${taskStartDate.getUTCMonth() + 1}/${taskStartDate.getUTCDate()}`;
                             const endStr = `${taskEndDate.getUTCMonth() + 1}/${taskEndDate.getUTCDate()}`;

                             let startHtml = showStartDateInBar ? `<span>${startStr}</span>` : '';
                             let endHtml = showEndDateInBar ? `<span>${endStr}</span>` : '';
                             let innerHtml = escapedInnerText ? `<span class="flex-grow text-center px-1 truncate">${escapedInnerText}</span>` : '<span class="flex-grow"></span>';

                             barClasses = 'task-bar flex items-center';
                             barContentHtml = `
                                <span class="flex justify-between items-center w-full h-full text-white text-[9px] overflow-hidden whitespace-nowrap px-1">
                                    ${startHtml}
                                    ${innerHtml}
                                    ${endHtml}
                                </span>`;

                             bodyHtml += `<div class="${barClasses}"
                                         title="${escapeHtml(task.name)}: ${task.start} ~ ${task.end}"
                                          style="top: ${topPosition}px; left: ${effectiveLeft}px; width: ${effectiveWidth}px; z-index: 6; background-color: ${task.color || '#3B82F6'};">
                                              ${barContentHtml}
                                     </div>`;
                         }
                     }
                 });
                 bodyHtml += '</div>'; // Close relative container

             } else if (selectedView === 'week') {
                 taskNameHeaderHtml = `<div class="task-name-col task-name-col-header flex items-center justify-center font-semibold text-xs text-gray-700 border-b border-r" style="position: sticky; left: 0; background-color: white;">項目</div>`;
                 headerRows = 2;
                 headerGridTemplateRows = 'auto auto';
                 unitWidth = 60;
                 totalUnits = 0;

                 let monthRowHtml = '';
                 let weekRowHtml = '';
                 let currentColIndex = 2;
                 columnsStyle = '';

                 let tempDate = new Date(timelineStartDate);
                 while (tempDate < timelineEndDate) {
                     const year = tempDate.getUTCFullYear();
                     const month = tempDate.getUTCMonth();
                     totalUnits += 4; // Each month gets 4 fixed weeks

                     const monthColSpan = 4;
                     monthRowHtml += `<div class="text-center border-b border-r text-sm font-semibold text-gray-700 flex items-center justify-center" style="grid-row: 1; grid-column: ${currentColIndex} / span ${monthColSpan};">${year}年 ${month + 1}月</div>`;

                     for (let i = 1; i <= 4; i++) {
                         weekRowHtml += `<div class="text-center border-b border-r text-[10px] font-medium text-gray-600 flex items-center justify-center py-1" style="grid-row: 2; grid-column: ${currentColIndex};">${i}W</div>`;
                         columnsStyle += ` ${unitWidth}px`;
                         currentColIndex++;
                     }
                     tempDate.setUTCMonth(tempDate.getUTCMonth() + 1);
                 }

                 headerHtml = taskNameHeaderHtml + monthRowHtml + weekRowHtml;
                 chartWidth = totalUnits * unitWidth;

                 gridHtml = '';
                 for (let i = 0; i <= totalUnits; i++) {
                     gridHtml += `<div class="grid-line" style="left: ${nameColWidth + i * unitWidth - 1}px; top: 0; height: ${tasksToRender.length * rowHeight}px;"></div>`; // Adjusted left offset
                 }
                 bodyHtml += `<div class="relative" style="height: ${tasksToRender.length * rowHeight}px; width: ${nameColWidth + chartWidth}px;">`;
                 bodyHtml += gridHtml;

                 // --- Bar Rendering for Fixed 4-Week Rule ---
                 const getOverallFixedWeekIndex = (targetDate, isEndDate = false) => {
                      const clampedDate = new Date(Math.max(timelineStartDate.getTime(), Math.min(targetDate.getTime(), timelineEndDate.getTime() - 1)));
                      let monthsDiff = (clampedDate.getUTCFullYear() - timelineStartDate.getUTCFullYear()) * 12 +
                                       (clampedDate.getUTCMonth() - timelineStartDate.getUTCMonth());
                      const fixedWeekInfo = getFixedWeekOfMonth(clampedDate); // { week, dayPosition }
                      let dayPosition = fixedWeekInfo.dayPosition;
                      if (isEndDate) {
                           dayPosition = Math.min(dayPosition + 0.999 / 7, 0.999); // Adjust for end date rendering
                       }
                       return monthsDiff * 4 + (fixedWeekInfo.week - 1) + dayPosition;
                  };

                 tasksToRender.forEach((task, index) => {
                     const taskStartDate = new Date(task.start + 'T00:00:00Z');
                     const taskEndDate = new Date(task.end + 'T00:00:00Z');

                     if (taskEndDate < timelineStartDate || taskStartDate >= timelineEndDate) return;

                     const startWeekIndex = getOverallFixedWeekIndex(taskStartDate, false);
                     const endWeekIndex = getOverallFixedWeekIndex(taskEndDate, true);

                     const topPosition = index * rowHeight + (rowHeight - 20) / 2;
                     // Use floor for start position, but include fraction for width calculation
                     const leftPosition = nameColWidth + Math.floor(startWeekIndex) * unitWidth + (startWeekIndex % 1) * unitWidth;
                     const barWidth = (endWeekIndex - startWeekIndex) * unitWidth - 2; // -2 padding

                     bodyHtml += `<div class="task-row-area absolute top-0 left-0 w-full border-b border-gray-200" style="top: ${index * rowHeight}px; height: ${rowHeight}px; z-index: 3;"></div>`;
                     bodyHtml += `<div class="task-name-col text-xs text-gray-800 px-2 flex items-center bg-white border-b border-gray-200" style="top: ${index * rowHeight}px; height: ${rowHeight}px; width: ${nameColWidth}px;"><span class="truncate" title="${escapeHtml(task.name)}">${escapeHtml(task.name)}</span></div>`;

                     if (barWidth > 0) {
                         const effectiveLeft = Math.max(nameColWidth, leftPosition);
                         const maxRight = nameColWidth + chartWidth;
                         const effectiveRight = Math.min(maxRight, leftPosition + barWidth);
                         let effectiveWidth = Math.max(0, effectiveRight - effectiveLeft);

                         if (effectiveWidth > 0) {
                             let barContentHtml = '';
                             let barClasses = 'task-bar flex items-center';
                             const taskInnerText = task.innerText || '';
                             const escapedInnerText = escapeHtml(taskInnerText || '');
                             const startStr = `${taskStartDate.getUTCMonth() + 1}/${taskStartDate.getUTCDate()}`;
                             const endStr = `${taskEndDate.getUTCMonth() + 1}/${taskEndDate.getUTCDate()}`;

                             let startHtml = showStartDateInBar ? `<span>${startStr}</span>` : '';
                             let endHtml = showEndDateInBar ? `<span>${endStr}</span>` : '';
                             let innerHtml = escapedInnerText ? `<span class="flex-grow text-center px-1 truncate">${escapedInnerText}</span>` : '<span class="flex-grow"></span>';

                             barClasses = 'task-bar flex items-center';
                             barContentHtml = `
                                <span class="flex justify-between items-center w-full h-full text-white text-[9px] overflow-hidden whitespace-nowrap px-1">
                                    ${startHtml}
                                    ${innerHtml}
                                    ${endHtml}
                                </span>`;

                             bodyHtml += `<div class="${barClasses}"
                                         title="${escapeHtml(task.name)}: ${task.start} ~ ${task.end}"
                                          style="top: ${topPosition}px; left: ${effectiveLeft}px; width: ${effectiveWidth}px; z-index: 6; background-color: ${task.color || '#3B82F6'};">
                                              ${barContentHtml}
                                     </div>`;
                         }
                     }
                 }); // End tasksToRender.forEach
                 bodyHtml += '</div>'; // Close relative container

             } else if (selectedView === 'month') {
                 taskNameHeaderHtml = `<div class="task-name-col border-b font-semibold text-xs text-gray-700 border-r flex items-center justify-center" style="position: sticky; left: 0; background-color: white;">項目</div>`;
                 headerRows = 1;
                 headerGridTemplateRows = 'auto';
                 unitWidth = 120;
                 totalUnits = 0;
                 let monthRowHtml = '';
                 let currentDate = new Date(timelineStartDate);
                 while (currentDate < timelineEndDate) {
                     const year = currentDate.getUTCFullYear();
                     const month = currentDate.getUTCMonth() + 1;
                     monthRowHtml += `<div class="text-center border-b border-r text-sm font-medium text-gray-700 flex items-center justify-center px-2 py-1">${year}/${String(month).padStart(2, '0')}</div>`;
                     columnsStyle += ` ${unitWidth}px`;
                     currentDate.setUTCMonth(currentDate.getUTCMonth() + 1);
                     totalUnits++;
                 }
                 headerHtml = taskNameHeaderHtml + monthRowHtml;
                 chartWidth = totalUnits * unitWidth;
                 // Calculate pxPerDay carefully based on the actual total days in the timeline
                 const totalDaysInTimeline = diffInDaysUTC(timelineEndDate, timelineStartDate);
                 let pxPerDay = totalDaysInTimeline > 0 ? chartWidth / totalDaysInTimeline : 0;


                 // Month View Body
                 gridHtml = '';
                 for (let i = 0; i <= totalUnits; i++) {
                     gridHtml += `<div class="grid-line" style="left: ${nameColWidth + i * unitWidth - 1}px; top: 0; height: ${tasksToRender.length * rowHeight}px;"></div>`; // Adjusted left offset
                 }
                 bodyHtml += `<div class="relative" style="height: ${tasksToRender.length * rowHeight}px; width: ${nameColWidth + chartWidth}px;">`;
                 bodyHtml += gridHtml;

                 tasksToRender.forEach((task, index) => {
                     const taskStartDate = new Date(task.start + 'T00:00:00Z');
                     const taskEndDate = new Date(task.end + 'T00:00:00Z');
                     const startOffsetDays = diffInDaysUTC(taskStartDate, timelineStartDate);
                     const durationDays = diffInDaysUTC(taskEndDate, taskStartDate) + 1;
                     const topPosition = index * rowHeight + (rowHeight - 20) / 2;
                     const leftPosition = nameColWidth + startOffsetDays * pxPerDay;
                     const barWidth = durationDays * pxPerDay - 2;

                     bodyHtml += `<div class="task-row-area absolute top-0 left-0 w-full border-b border-gray-200" style="top: ${index * rowHeight}px; height: ${rowHeight}px; z-index: 3;"></div>`;
                     bodyHtml += `<div class="task-name-col text-xs text-gray-800 px-2 flex items-center bg-white border-b border-gray-200" style="top: ${index * rowHeight}px; height: ${rowHeight}px; width: ${nameColWidth}px;"><span class="truncate" title="${escapeHtml(task.name)}">${escapeHtml(task.name)}</span></div>`;

                     if (barWidth > 0 && pxPerDay > 0) { // Ensure pxPerDay is valid
                         const effectiveLeft = Math.max(nameColWidth, leftPosition);
                         const effectiveRight = Math.min(nameColWidth + chartWidth, leftPosition + barWidth);
                         let effectiveWidth = Math.max(0, effectiveRight - effectiveLeft);

                         if (effectiveWidth > 0) {
                             let barContentHtml = '';
                             let barClasses = 'task-bar flex items-center';
                             const escapedInnerText = escapeHtml(task.innerText || '');
                             const startStr = `${taskStartDate.getUTCMonth() + 1}/${taskStartDate.getUTCDate()}`;
                             const endStr = `${taskEndDate.getUTCMonth() + 1}/${taskEndDate.getUTCDate()}`;

                             let startHtml = showStartDateInBar ? `<span>${startStr}</span>` : '';
                             let endHtml = showEndDateInBar ? `<span>${endStr}</span>` : '';
                             let innerHtml = escapedInnerText ? `<span class="flex-grow text-center px-1 truncate">${escapedInnerText}</span>` : '<span class="flex-grow"></span>';

                             barClasses = 'task-bar flex items-center';
                             barContentHtml = `
                                 <span class="flex justify-between items-center w-full h-full text-white text-[9px] overflow-hidden whitespace-nowrap px-1">
                                     ${startHtml}
                                     ${innerHtml}
                                     ${endHtml}
                                 </span>`;

                             bodyHtml += `<div class="${barClasses}"
                                        title="${escapeHtml(task.name)}: ${task.start} ~ ${task.end}"
                                         style="top: ${topPosition}px; left: ${effectiveLeft}px; width: ${effectiveWidth}px; z-index: 6; background-color: ${task.color || '#3B82F6'};">
                                             ${barContentHtml}
                                    </div>`;
                         }
                     }
                 });
                 bodyHtml += '</div>';
             }

             // --- Final Append ---
             const headerContainer = document.createElement('div');
             headerContainer.className = 'timeline-header grid border-t'; // Added border-t
             headerContainer.style.gridTemplateColumns = `${nameColWidth}px${columnsStyle}`;
             headerContainer.style.width = `${nameColWidth + chartWidth}px`;
             if(headerRows > 1) headerContainer.style.gridTemplateRows = headerGridTemplateRows;
             headerContainer.innerHTML = headerHtml;

             const bodyContainer = document.createElement('div');
             bodyContainer.className = 'relative';
             bodyContainer.style.width = `${nameColWidth + chartWidth}px`;
             bodyContainer.innerHTML = bodyHtml; // Body HTML (grid, background, bars)

              ganttChartDiv.appendChild(headerContainer);
              ganttChartDiv.appendChild(bodyContainer);

             // --- Dynamically set timeline header top based on title height ---
             requestAnimationFrame(() => {
                 try {
                     const titleElement = document.getElementById('chart-area-title');
                     const timelineHeaderElement = ganttChartDiv.querySelector('.timeline-header');
                     if (titleElement && timelineHeaderElement) {
                         const titleHeight = titleElement.offsetHeight;
                         if (titleHeight > 0) {
                             timelineHeaderElement.style.top = `${titleHeight}px`;
                         } else {
                             console.warn('Title height calculated as 0, header top not adjusted.');
                         }
                     } else {
                          console.warn('(RAF) Could not find title or timeline header element.');
                     }
                 } catch (error) {
                      console.error('(RAF) Error adjusting timeline header top:', error);
                 }
             });
             // --- End dynamic top adjustment ---

             renderTaskList(); // タスクリストも必ず再描画
             adjustStickyTitlePosition(); // 描画後に位置調整
             console.log('--- renderGanttChart END ---'); // Log End
         }

        function updateProjectName() {
            const projectName = projectNameInput.value.trim();
            const defaultPageTitle = "工程表";
            const defaultChartTitle = "工程表";

            // チャートエリアタイトル (h2) 更新
            // ganttTitleElement が存在するか確認
            if (ganttTitleElement) {
                ganttTitleElement.textContent = projectName ? `${projectName} ${defaultChartTitle}` : defaultChartTitle;
            } else {
                 console.error("ganttTitleElement not found during updateProjectName.");
            }
            // ページタイトル (document.title) 更新
            document.title = projectName ? `${projectName} ${defaultPageTitle}` : defaultPageTitle;

            adjustStickyTitlePosition(); // タイトル更新後にも位置調整
        }

        // loadProjectName 関数は loadProject に統合されたので不要
        // function loadProjectName() { ... }

        // --- 初期読み込み処理 ---
        loadAllProjects(); // まず全プロジェクトを読み込む
        const initialLastSelectedIdStr = localStorage.getItem('lastSelectedProjectId'); // ★ 変数名変更
        // lastSelectedIdStr が null でないことを確認してから loadProject を呼ぶ
        loadProject(initialLastSelectedIdStr); // ★ 変更した変数を使用
        renderProjectDeletionList(); // ★追加: 初期表示時に削除リストも描画

        // renderGanttChart(); // loadProject の中で呼ばれるので不要

        // ... (日付表示チェックボックス、祝日関連の初期化は変更なし) ...
        showHolidaysCheckbox.checked = showHolidays;
        showStartDateCheckbox.checked = showStartDateInBar;
        showEndDateCheckbox.checked = showEndDateInBar;
        updateHolidayCheckboxState();
        updateShowDatesCheckboxState();

        if (showHolidays) {
            fetchHolidays().then(() => {
                renderGanttChart(); // データ取得後に再描画
            });
        }

        window.addEventListener('load', adjustStickyTitlePosition);
        window.addEventListener('resize', adjustStickyTitlePosition);

        // projectNameInput のイベントリスナーをここに追加
         if (projectNameInput) {
             projectNameInput.addEventListener('input', () => {
                 updateProjectName(); // 入力中にタイトルを更新
                 // 新規プロジェクト編集中であることをドロップダウンに反映させる
                 if (currentProjectId === null) {
                     renderProjectDropdown();
                 }
             });
         } else {
              console.error("projectNameInput element not found during initial setup.");
         }

        // ★★★ 追加: ディープ比較関数 ★★★
        function deepCompare(obj1, obj2) {
            // 基本的な型チェックと値比較
            if (obj1 === obj2) return true;
            if (obj1 == null || obj2 == null || typeof obj1 !== "object" || typeof obj2 !== "object") return false;

            // Array comparison
            if (Array.isArray(obj1) && Array.isArray(obj2)) {
                if (obj1.length !== obj2.length) return false;
                for (let i = 0; i < obj1.length; i++) {
                    if (!deepCompare(obj1[i], obj2[i])) return false;
                }
                return true;
            }
            // Handle cases where one is array and other is not
            if (Array.isArray(obj1) !== Array.isArray(obj2)) return false;

            // Object comparison
            let keys1 = Object.keys(obj1);
            let keys2 = Object.keys(obj2);

            if (keys1.length !== keys2.length) return false;

            for (let key of keys1) {
                if (!keys2.includes(key) || !deepCompare(obj1[key], obj2[key])) {
                    return false;
                }
            }
            return true;
        }

        // ★★★ 追加: 未保存の変更があるかチェックする関数 ★★★
        function hasUnsavedChanges() {
            if (currentProjectId === null) {
                // 新規プロジェクトの場合: 名前かタスクがあれば変更ありとみなす
                return projectNameInput.value.trim() !== '' || tasks.length > 0;
            } else {
                // 既存プロジェクトの場合: 保存されている状態と比較
                const savedProject = savedProjects.find(p => p.id === currentProjectId);
                if (!savedProject) {
                    // 保存されているはずのプロジェクトが見つからない場合 (異常系)
                    console.warn("hasUnsavedChanges: Current project not found in savedProjects.");
                    return projectNameInput.value.trim() !== '' || tasks.length > 0; // 念のため変更あり扱い
                }
                const savedName = savedProject.name || '';
                const currentName = projectNameInput.value.trim();
                // 名前比較 + タスク配列比較 (deepCompare を使用)
                const tasksAreDifferent = !deepCompare(tasks, savedProject.tasks || []);
                // console.log(`Unsaved check for ID ${currentProjectId}: Name diff: ${currentName !== savedName}, Tasks diff: ${tasksAreDifferent}`); // デバッグ用
                return currentName !== savedName || tasksAreDifferent;
            }
        }

        // ★★★ 追加: プロジェクト削除リストを描画する関数 ★★★
        function renderProjectDeletionList() {
            if (!projectDeletionListDiv) {
                 console.error("projectDeletionListDiv element not found.");
                 return; // 要素がなければ何もしない
            }

            projectDeletionListDiv.innerHTML = ''; // クリア

            if (savedProjects.length === 0) {
                projectDeletionListDiv.innerHTML = '<p class="text-gray-400 text-xs italic p-1">保存されたプロジェクトはありません。</p>';
                return;
            }

            // 名前でソートして表示（オプション）
            const sortedProjects = [...savedProjects].sort((a, b) => (a.name || '').localeCompare(b.name || ''));

            sortedProjects.forEach(project => {
                const projectDiv = document.createElement('div');
                projectDiv.className = 'flex justify-between items-center p-1 hover:bg-gray-100 rounded';
                projectDiv.dataset.projectId = project.id; // 親要素にもIDを持たせる

                const nameSpan = document.createElement('span');
                nameSpan.className = 'text-xs truncate mr-2';
                nameSpan.textContent = project.name || `プロジェクト ${project.id}`;
                nameSpan.title = project.name || `プロジェクト ${project.id}`; // ホバーでフルネーム表示

                const deleteBtn = document.createElement('button');
                deleteBtn.type = 'button';
                deleteBtn.className = 'project-delete-icon text-red-400 hover:text-red-600 px-0.5 flex-shrink-0';
                deleteBtn.dataset.projectId = project.id; // ボタンに削除対象のIDを持たせる
                deleteBtn.title = '削除';
                // Lucide Trash Icon
                deleteBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-trash-2 inline-block pointer-events-none"><path d="M3 6h18"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></svg>`; // pointer-events-none を SVG に追加

                projectDiv.appendChild(nameSpan);
                projectDiv.appendChild(deleteBtn);
                projectDeletionListDiv.appendChild(projectDiv);
            });
        }

        // projectSelect change listener (変更: 未保存チェック追加)
        projectSelect.addEventListener('change', (event) => {
            const selectedId = event.target.value;
            if (selectedId && selectedId !== "new") {
                // ★変更: 保存されていない変更があるか確認
                if (hasUnsavedChanges()) {
                    if (!confirm("変更が保存されていません。プロジェクトを切り替えますか？")) {
                        // 選択を元に戻す (currentProjectIdがnullでない場合)
                        projectSelect.value = currentProjectId !== null ? currentProjectId.toString() : "";
                        return; // 切り替えをキャンセル
                    }
                }
                loadProject(selectedId);
            } else if (selectedId === "") {
                // ★変更: 保存されていない変更があるか確認
                if (hasUnsavedChanges()) {
                   if (!confirm("変更が保存されていません。プロジェクトを閉じますか？")) {
                       projectSelect.value = currentProjectId !== null ? currentProjectId.toString() : ""; // 選択を元に戻す
                       return; // 閉じるのをキャンセル
                   }
               }
                loadProject(null);
            }
        });

        // createNewProjectBtn click listener (変更: 未保存チェック追加, loadProject(null)でクリア)
        createNewProjectBtn.addEventListener('click', () => {
            // ★変更: 保存されていない変更があるか確認
            if (hasUnsavedChanges()) {
               if (!confirm("変更が保存されていません。新規プロジェクトを作成しますか？")) {
                   return; // 作成をキャンセル
               }
           }
            console.log("新規プロジェクト作成ボタンクリック");
            loadProject(null); // loadProject(null) で状態をクリア
            renderProjectDeletionList(); // loadProjectの中で呼ばれるが、念のためここでも呼ぶ
            projectNameInput.focus();
        });

        // saveProjectBtn click listener (変更: 保存後に削除リストも更新, 保存ロジック調整)
        saveProjectBtn.addEventListener('click', () => {
            const projectName = projectNameInput.value.trim();
            if (!projectName) {
                alert("プロジェクト名を入力してください。");
                projectNameInput.focus();
                return;
            }

            // ディープコピーして保存する (重要！)
            const tasksToSave = JSON.parse(JSON.stringify(tasks));

            let projectWasSavedOrCreated = false; // 保存または新規作成が行われたかフラグ
            let newOrUpdatedProjectId = currentProjectId; // 保存後のIDを保持

            if (currentProjectId !== null) {
                // --- 既存プロジェクトの上書き保存 ---
                const projectIndex = savedProjects.findIndex(p => p.id === currentProjectId);
                if (projectIndex !== -1) {
                    // 変更があった場合のみ保存する
                    if (projectName !== (savedProjects[projectIndex].name || '') || !deepCompare(tasksToSave, savedProjects[projectIndex].tasks || [])) {
                        savedProjects[projectIndex].name = projectName;
                        savedProjects[projectIndex].tasks = tasksToSave;
                        console.log(`既存プロジェクト上書き保存: ID=${currentProjectId}, Name=${projectName}`);
                        projectWasSavedOrCreated = true;
                    } else {
                         console.log("変更がないため、プロジェクトは上書き保存されませんでした。");
                    }
                } else {
                    console.error(`保存エラー: ID ${currentProjectId} のプロジェクトが見つかりません。新規として保存します。`);
                     currentProjectId = null; // 新規保存扱いに切り替え
                }
            }

            // currentProjectIdがnullの場合（新規またはエラーからの切り替え）
            if (currentProjectId === null) {
                // --- 新規プロジェクトの保存 ---
                if (savedProjects.length >= 10) {
                    alert("保存できるプロジェクトは最大10個までです。");
                    return;
                }
                const newProjectId = Date.now(); // 新しいIDを生成
                const newProject = {
                    id: newProjectId,
                    name: projectName,
                    tasks: tasksToSave
                };
                savedProjects.push(newProject);
                currentProjectId = newProjectId; // 保存したのでIDを設定
                newOrUpdatedProjectId = newProjectId;
                localStorage.setItem('lastSelectedProjectId', currentProjectId.toString());
                console.log(`新規プロジェクト保存: ID=${currentProjectId}, Name=${projectName}`);
                projectWasSavedOrCreated = true;
            }

            // 保存/新規作成が実際に行われた場合のみ localStorage を更新し、UIを再描画
            if (projectWasSavedOrCreated) {
                saveAllProjects();
                // ドロップダウンと削除リストを更新 (新しい名前や選択状態を反映)
                // loadProject(newOrUpdatedProjectId); // 再ロードすると変更フラグがリセットされる
                // 代わりに直接UIを更新
                renderProjectDropdown();
                renderProjectDeletionList();
                // 保存成功のメッセージ（オプション）
                // alert(`プロジェクト「${projectName}」を保存しました。`);
            } else {
                 // 保存されなかった場合でも、IDが変わった可能性があればUI更新
                 // (例: エラーから新規保存扱いになった場合 currentProjectId が null -> new ID に変わる)
                 if (newOrUpdatedProjectId !== projectSelect.value) { // ドロップダウンの選択とIDがずれたら更新
                    renderProjectDropdown();
                    renderProjectDeletionList();
                 }
             }
        });

        // ★★★ 削除: deleteProjectBtn リスナーを削除 ★★★
        // deleteProjectBtn.addEventListener('click', () => { ... });

        // ★★★ 追加: プロジェクト削除リストのイベントリスナー (イベント委譲) ★★★
        projectDeletionListDiv.addEventListener('click', (event) => {
            const deleteButton = event.target.closest('.project-delete-icon'); // ゴミ箱アイコンボタンを探す
            if (deleteButton && deleteButton.dataset.projectId) {
                const projectIdToDelete = parseInt(deleteButton.dataset.projectId, 10);
                if (isNaN(projectIdToDelete)) return;

                const projectToDelete = savedProjects.find(p => p.id === projectIdToDelete);
                const projectName = projectToDelete ? projectToDelete.name : `プロジェクト ${projectIdToDelete}`;

                if (confirm(`プロジェクト「${escapeHtml(projectName)}」を削除しますか？\nこの操作は元に戻せません。`)) {
                    savedProjects = savedProjects.filter(p => p.id !== projectIdToDelete);
                    console.log(`プロジェクト削除: ID=${projectIdToDelete}`);
                    saveAllProjects(); // 削除後の配列を保存

                    // 削除したプロジェクトが現在表示中のものだったら、表示をクリア
                    if (currentProjectId === projectIdToDelete) {
                        loadProject(null);
                        // loadProject(null)の中でrenderProjectDeletionListも呼ばれる
                    } else {
                        // 現在表示中のプロジェクトは維持し、リストだけ更新
                        renderProjectDropdown();
                        renderProjectDeletionList();
                    }
                }
            }
        });

    
document.addEventListener("click", function(e) {
    if (e.target.closest(".task-list-toggle")) {
        const btn = e.target.closest(".task-list-toggle");
        const targetId = btn.dataset.target?.replace("#", "");
        const detailsDiv = document.getElementById(targetId);
        if (detailsDiv) {
            detailsDiv.classList.toggle("hidden");
            const expanded = btn.getAttribute("aria-expanded") === "true";
            btn.setAttribute("aria-expanded", !expanded);
            btn.classList.toggle("rotate-180", !expanded);
        }
    }
});
</script>
</body>
</html>